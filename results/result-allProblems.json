{"version":"3","listProblem":[{
  "tool": "Code Inspection",
  "category": "Visibility",
  "type": "Class is exposed outside of its visibility scope",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Class `AfxAttributeElementType` is exposed outside its defined visibility scope",
  "detailsInfo": "Reports usages of classes in a field or method signature where the class has less visibility than the member that uses it. While legal Java, such members cannot be used outside of the visibility scope of the class type they reference.\n\n**Example:**\n\n\n      public class Parent {\n        public Child getChild() {\n          return new Child();\n        }\n\n        private class Child {}\n      }\n\n\nAdditionally, in Java 9 and higher, a module may hide some of its classes from other modules by not exporting their packages.\nHowever, if a member that is part of the exported API references a non-exported class in its signature,\nsuch a member cannot be used outside of the module.\n\nConfigure the inspection:\n\n* Use the **Report non-exported classes exposed in module API (Java 9+)** option to report module API members that expose non-exported classes.  \n  Note that the language level of the project or module needs to be 9 or higher for this option.\n* Use the **Report non-accessible classes exposed in public API** option to report on public members that expose classes with a smaller visibility scope.\n* Use the **Report private classes exposed in package-local API** option to report on package-local members that expose `private` classes.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/afx/psi/AfxElementTypes.java",
      "language": "JAVA",
      "line": 10,
      "offset": 19,
      "length": 23,
      "code": {
        "startLine": 8,
        "length": 23,
        "offset": 129,
        "surroundingCode": "public class AfxElementTypes {\n    public static AfxTagElementType AFX_TAG = new AfxTagElementType(\"AFX_TAG\");\n    public static AfxAttributeElementType AFX_ATTRIBUTE = new AfxAttributeElementType(\"AFX_ATTRIBUTE\");\n\n    public static AfxElementType AFX_EEL_START_DELIMITER = new AfxElementType(\"AFX_EEL_START_DELIMITER\");"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ClassEscapesItsScope"
  },
  "hash": "07fc7d0dd8a58fdd2fefa9002b268c30b715755916d21fdbb6b2746d84784195"
},{
  "tool": "Code Inspection",
  "category": "Visibility",
  "type": "Class is exposed outside of its visibility scope",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Class `AfxElementType` is exposed outside its defined visibility scope",
  "detailsInfo": "Reports usages of classes in a field or method signature where the class has less visibility than the member that uses it. While legal Java, such members cannot be used outside of the visibility scope of the class type they reference.\n\n**Example:**\n\n\n      public class Parent {\n        public Child getChild() {\n          return new Child();\n        }\n\n        private class Child {}\n      }\n\n\nAdditionally, in Java 9 and higher, a module may hide some of its classes from other modules by not exporting their packages.\nHowever, if a member that is part of the exported API references a non-exported class in its signature,\nsuch a member cannot be used outside of the module.\n\nConfigure the inspection:\n\n* Use the **Report non-exported classes exposed in module API (Java 9+)** option to report module API members that expose non-exported classes.  \n  Note that the language level of the project or module needs to be 9 or higher for this option.\n* Use the **Report non-accessible classes exposed in public API** option to report on public members that expose classes with a smaller visibility scope.\n* Use the **Report private classes exposed in package-local API** option to report on package-local members that expose `private` classes.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/afx/psi/AfxElementTypes.java",
      "language": "JAVA",
      "line": 13,
      "offset": 19,
      "length": 14,
      "code": {
        "startLine": 11,
        "length": 14,
        "offset": 125,
        "surroundingCode": "\n    public static AfxElementType AFX_EEL_START_DELIMITER = new AfxElementType(\"AFX_EEL_START_DELIMITER\");\n    public static AfxElementType AFX_EEL_END_DELIMITER = new AfxElementType(\"AFX_EEL_END_DELIMITER\");\n    public static AfxElementType AFX_EEL_VALUE = new AfxElementType(\"AFX_EEL_VALUE\");\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ClassEscapesItsScope"
  },
  "hash": "08ff5b6faf11d65994121ed6893b26d28abf882ad4ea90023a98861139b774ff"
},{
  "tool": "Code Inspection",
  "category": "Visibility",
  "type": "Class is exposed outside of its visibility scope",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Class `AfxElementType` is exposed outside its defined visibility scope",
  "detailsInfo": "Reports usages of classes in a field or method signature where the class has less visibility than the member that uses it. While legal Java, such members cannot be used outside of the visibility scope of the class type they reference.\n\n**Example:**\n\n\n      public class Parent {\n        public Child getChild() {\n          return new Child();\n        }\n\n        private class Child {}\n      }\n\n\nAdditionally, in Java 9 and higher, a module may hide some of its classes from other modules by not exporting their packages.\nHowever, if a member that is part of the exported API references a non-exported class in its signature,\nsuch a member cannot be used outside of the module.\n\nConfigure the inspection:\n\n* Use the **Report non-exported classes exposed in module API (Java 9+)** option to report module API members that expose non-exported classes.  \n  Note that the language level of the project or module needs to be 9 or higher for this option.\n* Use the **Report non-accessible classes exposed in public API** option to report on public members that expose classes with a smaller visibility scope.\n* Use the **Report private classes exposed in package-local API** option to report on package-local members that expose `private` classes.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/afx/psi/AfxElementTypes.java",
      "language": "JAVA",
      "line": 12,
      "offset": 19,
      "length": 14,
      "code": {
        "startLine": 10,
        "length": 14,
        "offset": 123,
        "surroundingCode": "    public static AfxAttributeElementType AFX_ATTRIBUTE = new AfxAttributeElementType(\"AFX_ATTRIBUTE\");\n\n    public static AfxElementType AFX_EEL_START_DELIMITER = new AfxElementType(\"AFX_EEL_START_DELIMITER\");\n    public static AfxElementType AFX_EEL_END_DELIMITER = new AfxElementType(\"AFX_EEL_END_DELIMITER\");\n    public static AfxElementType AFX_EEL_VALUE = new AfxElementType(\"AFX_EEL_VALUE\");"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ClassEscapesItsScope"
  },
  "hash": "5cef70396a5d58a9be75c47e7fa968be4a5fb123e6714cc55a126d47db8859b3"
},{
  "tool": "Code Inspection",
  "category": "Visibility",
  "type": "Class is exposed outside of its visibility scope",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Class `AfxTagElementType` is exposed outside its defined visibility scope",
  "detailsInfo": "Reports usages of classes in a field or method signature where the class has less visibility than the member that uses it. While legal Java, such members cannot be used outside of the visibility scope of the class type they reference.\n\n**Example:**\n\n\n      public class Parent {\n        public Child getChild() {\n          return new Child();\n        }\n\n        private class Child {}\n      }\n\n\nAdditionally, in Java 9 and higher, a module may hide some of its classes from other modules by not exporting their packages.\nHowever, if a member that is part of the exported API references a non-exported class in its signature,\nsuch a member cannot be used outside of the module.\n\nConfigure the inspection:\n\n* Use the **Report non-exported classes exposed in module API (Java 9+)** option to report module API members that expose non-exported classes.  \n  Note that the language level of the project or module needs to be 9 or higher for this option.\n* Use the **Report non-accessible classes exposed in public API** option to report on public members that expose classes with a smaller visibility scope.\n* Use the **Report private classes exposed in package-local API** option to report on package-local members that expose `private` classes.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/afx/psi/AfxElementTypes.java",
      "language": "JAVA",
      "line": 9,
      "offset": 19,
      "length": 17,
      "code": {
        "startLine": 7,
        "length": 17,
        "offset": 50,
        "surroundingCode": "\npublic class AfxElementTypes {\n    public static AfxTagElementType AFX_TAG = new AfxTagElementType(\"AFX_TAG\");\n    public static AfxAttributeElementType AFX_ATTRIBUTE = new AfxAttributeElementType(\"AFX_ATTRIBUTE\");\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ClassEscapesItsScope"
  },
  "hash": "91843fe368e336d6d736880b40feb50c42db47c63a0a7e7a3425ca7ce6f1fe63"
},{
  "tool": "Code Inspection",
  "category": "Visibility",
  "type": "Class is exposed outside of its visibility scope",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Class `AfxElementType` is exposed outside its defined visibility scope",
  "detailsInfo": "Reports usages of classes in a field or method signature where the class has less visibility than the member that uses it. While legal Java, such members cannot be used outside of the visibility scope of the class type they reference.\n\n**Example:**\n\n\n      public class Parent {\n        public Child getChild() {\n          return new Child();\n        }\n\n        private class Child {}\n      }\n\n\nAdditionally, in Java 9 and higher, a module may hide some of its classes from other modules by not exporting their packages.\nHowever, if a member that is part of the exported API references a non-exported class in its signature,\nsuch a member cannot be used outside of the module.\n\nConfigure the inspection:\n\n* Use the **Report non-exported classes exposed in module API (Java 9+)** option to report module API members that expose non-exported classes.  \n  Note that the language level of the project or module needs to be 9 or higher for this option.\n* Use the **Report non-accessible classes exposed in public API** option to report on public members that expose classes with a smaller visibility scope.\n* Use the **Report private classes exposed in package-local API** option to report on package-local members that expose `private` classes.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/afx/psi/AfxElementTypes.java",
      "language": "JAVA",
      "line": 14,
      "offset": 19,
      "length": 14,
      "code": {
        "startLine": 12,
        "length": 14,
        "offset": 226,
        "surroundingCode": "    public static AfxElementType AFX_EEL_START_DELIMITER = new AfxElementType(\"AFX_EEL_START_DELIMITER\");\n    public static AfxElementType AFX_EEL_END_DELIMITER = new AfxElementType(\"AFX_EEL_END_DELIMITER\");\n    public static AfxElementType AFX_EEL_VALUE = new AfxElementType(\"AFX_EEL_VALUE\");\n\n    static class AfxElementType extends IElementType {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ClassEscapesItsScope"
  },
  "hash": "99577a9736366917dc0e013708573a2103aef75be170d558c80d29e6a16df949"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "Redundant 'Collection.addAll()' call",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'addAll()' call can be replaced with parametrized constructor call",
  "detailsInfo": "Reports `Collection.addAll()` and `Map.putAll()` calls immediately after an instantiation of a collection using a no-arg constructor.\n\nSuch constructs can be replaced with a single call to a parametrized constructor, which simplifies the code. Also, for some collections the replacement\nmight be more performant.\n\n**Example:**\n\n\n      Set<String> set = new HashSet<>();\n      set.addAll(Arrays.asList(\"alpha\", \"beta\", \"gamma\"));\n\nAfter the quick-fix is applied:\n\n\n      Set<String> set = new HashSet<>(Arrays.asList(\"alpha\", \"beta\", \"gamma\"));\n\n\nThe JDK collection classes are supported by default.\nAdditionally, you can specify other classes using the **Classes to check** panel.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/util/PhpElementsUtil.java",
      "language": "JAVA",
      "line": 67,
      "offset": 16,
      "length": 6,
      "code": {
        "startLine": 65,
        "length": 6,
        "offset": 69,
        "surroundingCode": "\n        List<PsiElement> result = new ArrayList<>();\n        result.addAll(PhpIndex.getInstance(project).getAnyByFQN(fqnClassOrInterfaceName));\n        return result;\n   }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "CollectionAddAllCanBeReplacedWithConstructor"
  },
  "hash": "953204b5a0f45753900c4f98dc3ebb34bf9e6b1665646b0b8a3fa530a231a463"
},{
  "tool": "Code Inspection",
  "category": "Verbose or redundant code constructs",
  "type": "Condition is covered by further condition",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'parent instanceof FusionBlock' covered by subsequent condition 'parent instanceof FusionPrototypeSignature'",
  "detailsInfo": "Reports conditions that become redundant as they are completely covered by a subsequent condition.\n\nFor example, in the `value != -1 && value > 0` condition, the first part is redundant:\nif it's false, then the second part is also false.\nOr in a condition like `obj != null && obj instanceof String`,\nthe null-check is redundant as `instanceof` operator implies non-nullity.\n\nNew in 2018.3",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/refactoring/MovePrototypeToFile.java",
      "language": "JAVA",
      "line": 128,
      "offset": 17,
      "length": 29,
      "code": {
        "startLine": 126,
        "length": 29,
        "offset": 112,
        "surroundingCode": "        while (parent != null) {\n            // TODO: there might be a better way to check this\n            if (parent instanceof FusionBlock || parent instanceof FusionPrototypeSignature) {\n                return false;\n            }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConditionCoveredByFurtherCondition"
  },
  "hash": "467aa6762220b64d9463929fe6b86c93f54960dff92c7818c27d33bb1a0d0f80"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `element instanceof FusionPrototypeSignature` is always `true`",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/usages/PrototypeFindUsagesProvider.java",
      "language": "JAVA",
      "line": 77,
      "offset": 13,
      "length": 43,
      "code": {
        "startLine": 75,
        "length": 43,
        "offset": 122,
        "surroundingCode": "    @Override\n    public @Nls @NotNull String getNodeText(@NotNull PsiElement element, boolean useFullName) {\n        if (element instanceof FusionPrototypeSignature) {\n            FusionType type = ((FusionPrototypeSignature) element).getType();\n            if (type != null && type.getText() != null) {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "01f654d5a1035965b822976614232050dadd11829cab0feefaf8a31396b0cebc"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Result of `e.getParent()` is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/editor/FusionBreadcrumbsInfoProvider.java",
      "language": "JAVA",
      "line": 63,
      "offset": 59,
      "length": 13,
      "code": {
        "startLine": 61,
        "length": 13,
        "offset": 109,
        "surroundingCode": "\n        if (e instanceof FusionAssignmentValue) {\n            FusionPath path = ((FusionPropertyAssignment) e.getParent()).getPath();\n            return path.getLastChild();\n        }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "03c63a51cdc0c107f232fee6db3d57d0933f11136a563dc74a460eb7432331ef"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `part instanceof FusionMetaProperty` is always `true`",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/structure/FusionTreeElement.java",
      "language": "JAVA",
      "line": 144,
      "offset": 21,
      "length": 34,
      "code": {
        "startLine": 142,
        "length": 34,
        "offset": 86,
        "surroundingCode": "\n            for (PsiElement part : getElement().getChildren()) {\n                if (part instanceof FusionMetaProperty) {\n                    return FusionIcons.META;\n                } else if (part instanceof FusionPrototypeSignature) {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "13f463fa4d2b22e4fae1414cd69dba4d823ff161a893a18198ebf1fc405b344d"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Result of `getParent().getParent()` is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/ext/FusionCopiedPrototypeSignatureImplMixin.java",
      "language": "JAVA",
      "line": 36,
      "offset": 20,
      "length": 23,
      "code": {
        "startLine": 34,
        "length": 23,
        "offset": 148,
        "surroundingCode": "                || (isSingleElementInPathAtFileRoot()\n                && (getParent().getParent() instanceof FusionPropertyBlock\n                || getParent().getParent() instanceof FusionPropertyCopy));\n    }\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "5451d90f6e1dfd3b75c1b0dd1193d813a93311e44e420108d62731cf1a28fc4e"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `e instanceof FusionBlock && e.getParent() instanceof FusionPropertyCopy` is always `false`",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/editor/FusionBreadcrumbsInfoProvider.java",
      "language": "JAVA",
      "line": 57,
      "offset": 13,
      "length": 71,
      "code": {
        "startLine": 55,
        "length": 71,
        "offset": 23,
        "surroundingCode": "        }\n\n        if (e instanceof FusionBlock && e.getParent() instanceof FusionPropertyCopy) {\n            FusionPath path = ((FusionPropertyCopy) e.getParent()).getPath();\n            return path.getLastChild();"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "5a020432a770e90086d8ab8340214b9d9d82a2dd5e7e1d4c44d5476ed5486cf1"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `parentElement instanceof FusionCopiedPrototypeSignature` is always `false`",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/usages/UsagesTypeProvider.java",
      "language": "JAVA",
      "line": 56,
      "offset": 17,
      "length": 55,
      "code": {
        "startLine": 54,
        "length": 55,
        "offset": 31,
        "surroundingCode": "            }\n\n            if (parentElement instanceof FusionCopiedPrototypeSignature) {\n                return INHERITED;\n            }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "664bf7939f7a8758a7c10a44df5e32c0f94e9348154bb18f467ead9e39b0fd6d"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `psiElement instanceof FusionPrototypeSignature` is always `true`",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/usages/PrototypeFindUsagesProvider.java",
      "language": "JAVA",
      "line": 49,
      "offset": 16,
      "length": 46,
      "code": {
        "startLine": 47,
        "length": 46,
        "offset": 99,
        "surroundingCode": "    @Override\n    public boolean canFindUsagesFor(@NotNull PsiElement psiElement) {\n        return psiElement instanceof FusionPrototypeSignature;\n    }\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "6fa85b2d39055a8acc22a3cef2e011cd8132a0dae189635c601523408ad15dd9"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value `parentElement` is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/usages/UsagesTypeProvider.java",
      "language": "JAVA",
      "line": 56,
      "offset": 17,
      "length": 13,
      "code": {
        "startLine": 54,
        "length": 13,
        "offset": 31,
        "surroundingCode": "            }\n\n            if (parentElement instanceof FusionCopiedPrototypeSignature) {\n                return INHERITED;\n            }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "71695ac28e10696730493a6716629d596e21110380b4074586a68656e961de15"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `getElement() != null` is always `true`",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/resolve/ref/FusionStringReference.java",
      "language": "JAVA",
      "line": 39,
      "offset": 13,
      "length": 20,
      "code": {
        "startLine": 37,
        "length": 20,
        "offset": 103,
        "surroundingCode": "    List<PsiElement> resolveInner() {\n        List<PsiElement> result = new ArrayList<>();\n        if (getElement() != null && getElement().getValueStringLineContent() != null) {\n            // find classes\n            String value = getElement().getValueStringLineContent().getText();"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "71b26f94aa6c09d7fba9aa4cd238177107bc3b4b1044d9517ca7609fd829c417"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `!(currentSibling instanceof FusionBlock)` is always `false` when reached",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/structure/FusionTreeElement.java",
      "language": "JAVA",
      "line": 92,
      "offset": 48,
      "length": 40,
      "code": {
        "startLine": 90,
        "length": 40,
        "offset": 134,
        "surroundingCode": "                    currentSibling = currentSibling.getFirstChild();\n                }\n            } while (currentSibling != null && !(currentSibling instanceof FusionBlock));\n\n            blockElement = currentSibling;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "78a44845af3a49d26d94ca451933a5e6fba0676623b2267d94299ec21d4f89a7"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Result of `getParent().getParent()` is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/ext/FusionPrototypeSignatureImplMixin.java",
      "language": "JAVA",
      "line": 49,
      "offset": 20,
      "length": 23,
      "code": {
        "startLine": 47,
        "length": 23,
        "offset": 148,
        "surroundingCode": "                || (isSingleElementInPathAtFileRoot()\n                && (getParent().getParent() instanceof FusionPropertyBlock\n                || getParent().getParent() instanceof FusionPropertyCopy));\n    }\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "78d40e37d5789a8906a12e3f79b39ab4e8e1b64bbfc532f0bba737eeb009bb20"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `e.getParent() instanceof FusionPropertyCopy` is always `false` when reached",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/editor/FusionBreadcrumbsInfoProvider.java",
      "language": "JAVA",
      "line": 57,
      "offset": 41,
      "length": 43,
      "code": {
        "startLine": 55,
        "length": 43,
        "offset": 51,
        "surroundingCode": "        }\n\n        if (e instanceof FusionBlock && e.getParent() instanceof FusionPropertyCopy) {\n            FusionPath path = ((FusionPropertyCopy) e.getParent()).getPath();\n            return path.getLastChild();"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "7c648bf8fd984b8b4097f71a3d1356532ae7e15d8e64d6e231de1530369dcfd6"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `element instanceof FusionPrototypeSignature` is always `true`",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/usages/PrototypeFindUsagesProvider.java",
      "language": "JAVA",
      "line": 65,
      "offset": 13,
      "length": 43,
      "code": {
        "startLine": 63,
        "length": 43,
        "offset": 108,
        "surroundingCode": "    @Override\n    public @Nls @NotNull String getDescriptiveName(@NotNull PsiElement element) {\n        if (element instanceof FusionPrototypeSignature) {\n            FusionType type = ((FusionPrototypeSignature) element).getType();\n            if (type != null && type.getText() != null) {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "7da52adb29306bfdb5694f8e571a2c0cb167e8c25ffae9e0804a503c0787cc8a"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `e instanceof FusionMetaProperty` is always `true`",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/editor/FusionBreadcrumbsInfoProvider.java",
      "language": "JAVA",
      "line": 81,
      "offset": 13,
      "length": 31,
      "code": {
        "startLine": 79,
        "length": 31,
        "offset": 92,
        "surroundingCode": "    @Override\n    public @Nullable Icon getElementIcon(@NotNull PsiElement e) {\n        if (e instanceof FusionMetaProperty) {\n            return FusionIcons.META;\n        }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "836b21e3c8d327f3fb99ca3c9bdc4c1eb6061e95c20c0be46353732c92901abd"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `ideaEvent.getData() instanceof AbstractMessage` is always `true` when reached",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/errorReporting/SentryErrorReporter.java",
      "language": "JAVA",
      "line": 45,
      "offset": 60,
      "length": 46,
      "code": {
        "startLine": 43,
        "length": 46,
        "offset": 167,
        "surroundingCode": "        ArrayList<String> eventIds = new ArrayList<>();\n        for (IdeaLoggingEvent ideaEvent : events) {\n            if (ideaEvent instanceof IdeaReportingEvent && ideaEvent.getData() instanceof AbstractMessage) {\n                Throwable ex = ((AbstractMessage) ideaEvent.getData()).getThrowable();\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "8586447b6281bdd48c94426cd4f75f769d59bf1e8d51ac2ed4bacd71eb4d2e1d"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `e instanceof FusionSinglePath` is always `true`",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/editor/FusionBreadcrumbsInfoProvider.java",
      "language": "JAVA",
      "line": 47,
      "offset": 16,
      "length": 29,
      "code": {
        "startLine": 45,
        "length": 29,
        "offset": 87,
        "surroundingCode": "    @Override\n    public boolean acceptElement(@NotNull PsiElement e) {\n        return e instanceof FusionSinglePath || e instanceof FusionMetaProperty || e instanceof FusionPrototypeSignature;\n    }\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "931336d1ef2eb466f7d6b1c4b912c126d94673dfed4f5915eb673c9fba0fe2fd"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `e instanceof FusionSinglePath || e instanceof FusionMetaProperty || e instanceof FusionPrototypeSign...` is always `true`",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/editor/FusionBreadcrumbsInfoProvider.java",
      "language": "JAVA",
      "line": 47,
      "offset": 16,
      "length": 105,
      "code": {
        "startLine": 45,
        "length": 105,
        "offset": 87,
        "surroundingCode": "    @Override\n    public boolean acceptElement(@NotNull PsiElement e) {\n        return e instanceof FusionSinglePath || e instanceof FusionMetaProperty || e instanceof FusionPrototypeSignature;\n    }\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "9bc854ac33b37aa7ebc9b472cedd842341a7a347e80983184caec54796a5d411"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `getParent().getParent() instanceof FusionPropertyCopy` is always `false` when reached",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/ext/FusionPrototypeSignatureImplMixin.java",
      "language": "JAVA",
      "line": 49,
      "offset": 20,
      "length": 53,
      "code": {
        "startLine": 47,
        "length": 53,
        "offset": 148,
        "surroundingCode": "                || (isSingleElementInPathAtFileRoot()\n                && (getParent().getParent() instanceof FusionPropertyBlock\n                || getParent().getParent() instanceof FusionPropertyCopy));\n    }\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "9de5b7e80213fef208d8ab85a494ef8f11c32644ee488164eaeef7e06eb153ab"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `parentElement instanceof FusionPrototypeSignature` is always `false`",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/usages/UsagesTypeProvider.java",
      "language": "JAVA",
      "line": 47,
      "offset": 17,
      "length": 49,
      "code": {
        "startLine": 45,
        "length": 49,
        "offset": 31,
        "surroundingCode": "            }\n\n            if (parentElement instanceof FusionPrototypeSignature) {\n                PsiElement parentParentElement = parentElement.getParent();\n                if (parentParentElement instanceof FusionPropertyDeletion) {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "a072d65adaf5decbbfc13a4675f42af8458089376ebe0387b090b230fe1eabfe"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value `tag` is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/afx/codeInsight/AfxXmlExtension.java",
      "language": "JAVA",
      "line": 51,
      "offset": 56,
      "length": 3,
      "code": {
        "startLine": 49,
        "length": 3,
        "offset": 253,
        "surroundingCode": "    public @NotNull AttributeValuePresentation getAttributeValuePresentation(@Nullable XmlTag tag, @NotNull String attributeName, @NotNull String defaultAttributeQuote) {\n        if (tag == null) {\n            return super.getAttributeValuePresentation(tag, attributeName, defaultAttributeQuote);\n        }\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "a272664dd3d03d050242e11460205f7af009566f314f555181a2d12ed45a6dfc"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `compositeElement instanceof EelCompositeIdentifier` is always `true`",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/eel/resolve/ref/EelMethodNameReference.java",
      "language": "JAVA",
      "line": 25,
      "offset": 21,
      "length": 50,
      "code": {
        "startLine": 23,
        "length": 50,
        "offset": 232,
        "surroundingCode": "            if (parentElement.getPrevSibling() != null && parentElement.getPrevSibling().getPrevSibling() != null) {\n                PsiElement compositeElement = parentElement.getPrevSibling().getPrevSibling();\n                if (compositeElement instanceof EelCompositeIdentifier) {\n                    return ResolveEngine.getEelHelperMethods(getElement().getProject(), compositeElement.getText(), getElement().getText());\n                }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "a6c8eddd048cd00454550c8f3d307de63ce3b7ed20d665f3bbe28b8d08925763"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `parent instanceof FusionPrototypeInstance` is always `true`",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/util/NeosUtil.java",
      "language": "JAVA",
      "line": 107,
      "offset": 17,
      "length": 41,
      "code": {
        "startLine": 105,
        "length": 41,
        "offset": 128,
        "surroundingCode": "        PsiElement parent = psi.getParent();\n        while(!(parent instanceof FusionFile) && parent != null) {\n            if (parent instanceof FusionPrototypeInstance) {\n                prototypes.add(((FusionPrototypeInstance) parent).getType().getText());\n                return prototypes;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "a94720d3929d7ecac7583a9e7ca3cc1f27721fb6b2b53329fd68c5acb1c3042c"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Result of `e.getParent()` is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/editor/FusionBreadcrumbsInfoProvider.java",
      "language": "JAVA",
      "line": 57,
      "offset": 41,
      "length": 13,
      "code": {
        "startLine": 55,
        "length": 13,
        "offset": 51,
        "surroundingCode": "        }\n\n        if (e instanceof FusionBlock && e.getParent() instanceof FusionPropertyCopy) {\n            FusionPath path = ((FusionPropertyCopy) e.getParent()).getPath();\n            return path.getLastChild();"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "abead2b2c009afa437c20e5a435b1b6fdd668b1aa0a25263b2523acdec16d557"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `getParent().getParent() instanceof FusionPropertyCopy` is always `false` when reached",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/ext/FusionCopiedPrototypeSignatureImplMixin.java",
      "language": "JAVA",
      "line": 36,
      "offset": 20,
      "length": 53,
      "code": {
        "startLine": 34,
        "length": 53,
        "offset": 148,
        "surroundingCode": "                || (isSingleElementInPathAtFileRoot()\n                && (getParent().getParent() instanceof FusionPropertyBlock\n                || getParent().getParent() instanceof FusionPropertyCopy));\n    }\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "b516cf190b8015d52b196fec7d2e466c5382dcb5625f7bc5f4740f954540e8bf"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `parent instanceof FusionBlock || parent instanceof FusionPrototypeSignature` is always `true`",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/refactoring/MovePrototypeToFile.java",
      "language": "JAVA",
      "line": 128,
      "offset": 17,
      "length": 75,
      "code": {
        "startLine": 126,
        "length": 75,
        "offset": 112,
        "surroundingCode": "        while (parent != null) {\n            // TODO: there might be a better way to check this\n            if (parent instanceof FusionBlock || parent instanceof FusionPrototypeSignature) {\n                return false;\n            }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "b95d49c8034f2a9e1f3d8287ceac59b1e98b63254a4a6ee5cd0f4367e053a225"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `element instanceof EelMethodCall` is always `true`",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/eel/codeInsight/hints/EelInlayParameterHintsProvider.java",
      "language": "JAVA",
      "line": 34,
      "offset": 13,
      "length": 32,
      "code": {
        "startLine": 32,
        "length": 32,
        "offset": 74,
        "surroundingCode": "        ArrayList<InlayInfo> inlayInfos = new ArrayList<>();\n\n        if (element instanceof EelMethodCall) {\n            List<PsiElement> phpMethods = null;\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "c53319335d06d0225c5093a430ac2c9464d2735431c8cb151aa96021288f9a8c"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `e instanceof FusionBlock` is always `true`",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/editor/FusionBreadcrumbsInfoProvider.java",
      "language": "JAVA",
      "line": 52,
      "offset": 13,
      "length": 24,
      "code": {
        "startLine": 50,
        "length": 24,
        "offset": 93,
        "surroundingCode": "    @Override\n    public @Nullable PsiElement getParent(@NotNull PsiElement e) {\n        if (e instanceof FusionBlock && e.getParent() instanceof FusionPropertyBlock) {\n            FusionPath path = ((FusionPropertyBlock) e.getParent()).getPath();\n            return path.getLastChild();"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "cff7dd00843a39293fb063690c50834f4ee897d7d127080160cfcafdba07859f"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value `parentElement` is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/usages/UsagesTypeProvider.java",
      "language": "JAVA",
      "line": 47,
      "offset": 17,
      "length": 13,
      "code": {
        "startLine": 45,
        "length": 13,
        "offset": 31,
        "surroundingCode": "            }\n\n            if (parentElement instanceof FusionPrototypeSignature) {\n                PsiElement parentParentElement = parentElement.getParent();\n                if (parentParentElement instanceof FusionPropertyDeletion) {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "d6d1b68772d093773318574def0e629d4a873ef2fb87a6200cbd5aaf5cce982a"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `element instanceof FusionPropertyCopy` is always `true`",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/annotators/PrototypeInheritanceAnnotator.java",
      "language": "JAVA",
      "line": 33,
      "offset": 13,
      "length": 37,
      "code": {
        "startLine": 31,
        "length": 37,
        "offset": 116,
        "surroundingCode": "    @Override\n    public void annotate(@NotNull PsiElement element, @NotNull AnnotationHolder holder) {\n        if (element instanceof FusionPropertyCopy) {\n            FusionPropertyCopy copy = (FusionPropertyCopy) element;\n            if (copy.isPrototypeInheritance()"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "d968611f54ce3d73dcd8df32a3586ca95f38152febb06201f88d7f90dfcee3fe"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `e instanceof FusionAssignmentValue` is always `true`",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/editor/FusionBreadcrumbsInfoProvider.java",
      "language": "JAVA",
      "line": 62,
      "offset": 13,
      "length": 34,
      "code": {
        "startLine": 60,
        "length": 34,
        "offset": 23,
        "surroundingCode": "        }\n\n        if (e instanceof FusionAssignmentValue) {\n            FusionPath path = ((FusionPropertyAssignment) e.getParent()).getPath();\n            return path.getLastChild();"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "e025d5718d37a47b911870b62650d2c8d26a55a4e7cb798fcce780fadd282af1"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `element instanceof FusionPrototypeSignature` is always `true`",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/refactoring/FusionRefactoringSupportProvider.java",
      "language": "JAVA",
      "line": 16,
      "offset": 17,
      "length": 43,
      "code": {
        "startLine": 14,
        "length": 43,
        "offset": 141,
        "surroundingCode": "    @Override\n    public boolean isMemberInplaceRenameAvailable(@NotNull PsiElement element, @Nullable PsiElement context) {\n        return (element instanceof FusionPrototypeSignature);\n    }\n}"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "e0f842c78a5d66550f76f7b019cc7636250b272cd894299a9c3ee91962d0be61"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `e instanceof FusionBlock` is always `true`",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/editor/FusionBreadcrumbsInfoProvider.java",
      "language": "JAVA",
      "line": 57,
      "offset": 13,
      "length": 24,
      "code": {
        "startLine": 55,
        "length": 24,
        "offset": 23,
        "surroundingCode": "        }\n\n        if (e instanceof FusionBlock && e.getParent() instanceof FusionPropertyCopy) {\n            FusionPath path = ((FusionPropertyCopy) e.getParent()).getPath();\n            return path.getLastChild();"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "e8d11e7b0c1720d7b6011ff05a58405e5569ca74b617538a415a62265c7720ce"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `e instanceof FusionPrototypeSignature` is always `true`",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/editor/FusionBreadcrumbsInfoProvider.java",
      "language": "JAVA",
      "line": 107,
      "offset": 13,
      "length": 37,
      "code": {
        "startLine": 105,
        "length": 37,
        "offset": 55,
        "surroundingCode": "        String elementInfo = e.getText();\n\n        if (e instanceof FusionPrototypeSignature) {\n            if (truncate) {\n                FusionType type = ((FusionPrototypeSignature) e).getType();"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "eb564171c56d32842cb92070bd5db4d2fdce763be8222c5b080cbcac8d3c99a7"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `currentSibling != null && !(currentSibling instanceof FusionBlock)` is always `false`",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/structure/FusionTreeElement.java",
      "language": "JAVA",
      "line": 92,
      "offset": 22,
      "length": 66,
      "code": {
        "startLine": 90,
        "length": 66,
        "offset": 108,
        "surroundingCode": "                    currentSibling = currentSibling.getFirstChild();\n                }\n            } while (currentSibling != null && !(currentSibling instanceof FusionBlock));\n\n            blockElement = currentSibling;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "f5b27a104fa53386e0de89454038882717ab3bff6e14810997d2dee8bbfe5ff7"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `parent instanceof FusionBlock` is always `true`",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/refactoring/MovePrototypeToFile.java",
      "language": "JAVA",
      "line": 128,
      "offset": 17,
      "length": 29,
      "code": {
        "startLine": 126,
        "length": 29,
        "offset": 112,
        "surroundingCode": "        while (parent != null) {\n            // TODO: there might be a better way to check this\n            if (parent instanceof FusionBlock || parent instanceof FusionPrototypeSignature) {\n                return false;\n            }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "f8510377746090cb1df3f09fd61c7e9c6324ef43d63d56adaae14981b4048494"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition `getElement() != null` is always `true`",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/resolve/ref/FusionResourceStringReference.java",
      "language": "JAVA",
      "line": 41,
      "offset": 13,
      "length": 20,
      "code": {
        "startLine": 39,
        "length": 20,
        "offset": 66,
        "surroundingCode": "        List<PsiElement> result = new ArrayList<>();\n\n        if (getElement() != null && getElement().getValueStringLineContent() != null) {\n            VirtualFile resourceFile = ResolveEngine.findResource(getElement().getContainingFile(), getElement().getValueStringLineContent().getText());\n            if (resourceFile != null && !resourceFile.isDirectory()) {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "f9f0c63e36b59cbf6d65cee719d74093b90ee4c329737bf502d977635a528f84"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `getElement().getFirstChild() instanceof FusionPrototypeSignature` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/structure/FusionTreeElement.java",
      "language": "JAVA",
      "line": 152,
      "offset": 13,
      "length": 64,
      "code": {
        "startLine": 150,
        "length": 64,
        "offset": 23,
        "surroundingCode": "        }\n\n        if (getElement().getFirstChild() instanceof FusionPrototypeSignature) {\n            return FusionIcons.PROTOTYPE;\n        }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "05d4fab941d710492dc2f0796d30f5d8b33c82b512247924466e043d69bf1acf"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `compositeElement instanceof EelCompositeIdentifier` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/eel/codeInsight/hints/EelInlayParameterHintsProvider.java",
      "language": "JAVA",
      "line": 41,
      "offset": 21,
      "length": 50,
      "code": {
        "startLine": 39,
        "length": 50,
        "offset": 223,
        "surroundingCode": "            if (methodCall.getPrevSibling() != null && methodCall.getPrevSibling().getPrevSibling() != null) {\n                PsiElement compositeElement = methodCall.getPrevSibling().getPrevSibling();\n                if (compositeElement instanceof EelCompositeIdentifier) {\n                    phpMethods = ResolveEngine.getEelHelperMethods(methodCall.getProject(), compositeElement.getText(), methodCall.getMethodName().getText());\n                }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "09c60c5b9f22e9c11cae2641be2bfbad93440bb9712792ce04f732c4544c9dd5"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `getElement() instanceof FusionPath` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/structure/FusionTreeElement.java",
      "language": "JAVA",
      "line": 85,
      "offset": 20,
      "length": 34,
      "code": {
        "startLine": 83,
        "length": 34,
        "offset": 102,
        "surroundingCode": "        if (getElement() instanceof FusionFile) {\n            return getElement();\n        } else if (getElement() instanceof FusionPath) {\n            PsiElement currentSibling = getElement();\n            do {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "0e8c81347376acb53a4aa75f3dfb23d2dbbb9d87e650d16ceb7fc7a2edbccd3c"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `getElement() instanceof FusionPath` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/structure/FusionTreeElement.java",
      "language": "JAVA",
      "line": 138,
      "offset": 13,
      "length": 34,
      "code": {
        "startLine": 136,
        "length": 34,
        "offset": 23,
        "surroundingCode": "        }\n\n        if (getElement() instanceof FusionPath) {\n            if (getElement().getParent() != null && getElement().getParent() instanceof FusionPropertyDeletion) {\n                return FusionIcons.UNSET;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "10ec274976731118ebeb65054b0346e3394b8eb2dc16d16bff84b1b1bca9586b"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `getElement().getParent() instanceof FusionPropertyDeletion` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/structure/FusionTreeElement.java",
      "language": "JAVA",
      "line": 139,
      "offset": 53,
      "length": 58,
      "code": {
        "startLine": 137,
        "length": 58,
        "offset": 103,
        "surroundingCode": "\n        if (getElement() instanceof FusionPath) {\n            if (getElement().getParent() != null && getElement().getParent() instanceof FusionPropertyDeletion) {\n                return FusionIcons.UNSET;\n            }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "1ae701b620345de04ec723a89597851f4b40e5770498ae0029350e4ea2f89075"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `parentElement instanceof FusionPrototypeInstance` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/usages/UsagesTypeProvider.java",
      "language": "JAVA",
      "line": 43,
      "offset": 17,
      "length": 48,
      "code": {
        "startLine": 41,
        "length": 48,
        "offset": 121,
        "surroundingCode": "        if (element instanceof FusionType) {\n            PsiElement parentElement = element.getParent();\n            if (parentElement instanceof FusionPrototypeInstance) {\n                return INSTANCE;\n            }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "26087e12be364371468a97c54cf1ca58e452b6e02e4b582323bf9cecbbd361a7"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Argument `resource` might be null",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/xliff/XliffSchemaProvider.java",
      "language": "JAVA",
      "line": 21,
      "offset": 61,
      "length": 8,
      "code": {
        "startLine": 19,
        "length": 8,
        "offset": 295,
        "surroundingCode": "    public @Nullable XmlFile getSchema(@NotNull @NonNls String url, @Nullable Module module, @NotNull PsiFile baseFile) {\n        final URL resource = XliffSchemaProvider.class.getResource(\"/de/vette/idea/neos/xsd/xliff/xliff12.xsd\");\n        final VirtualFile fileByURL = VfsUtil.findFileByURL(resource);\n        PsiFile result = baseFile.getManager().findFile(fileByURL);\n        if (result instanceof XmlFile) {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "2ef1b32c4eea68bfc769128fc7572e0c2a309eb23e56a6bd15d61ee5dfdd116d"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `e instanceof FusionPrototypeSignature` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/refactoring/MovePrototypeToFile.java",
      "language": "JAVA",
      "line": 69,
      "offset": 78,
      "length": 37,
      "code": {
        "startLine": 67,
        "length": 37,
        "offset": 217,
        "surroundingCode": "        editor.getCaretModel().getAllCarets().forEach(caret -> {\n            PsiElement element = psiFile.findElementAt(caret.getOffset());\n            PsiElement signature = PsiTreeUtil.findFirstParent(element, e -> e instanceof FusionPrototypeSignature);\n            if (isTopLevelPrototype(signature)) {\n                selectedSignatures.add((FusionPrototypeSignature) signature);"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "360a2996c1e9847dbc9d9f192b908d97b12c9be3a2440bb74b1be642028601d6"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `el.getParent() instanceof FusionPrototypeSignature` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/annotators/NodeTypeLineMarkerProvider.java",
      "language": "JAVA",
      "line": 46,
      "offset": 26,
      "length": 50,
      "code": {
        "startLine": 44,
        "length": 50,
        "offset": 110,
        "surroundingCode": "        for (PsiElement el : elements) {\n            if (!(el instanceof FusionType)\n                    || !(el.getParent() instanceof FusionPrototypeSignature)\n                    || (el.getParent().getParent().getParent() instanceof FusionPropertyDeletion)) {\n                continue;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "3955c3731d3438af1ec2cb5b09935b86d8181a885a5d404063f775ef48e281cc"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `getParent().getParent() instanceof FusionPropertyBlock` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/ext/FusionPrototypeSignatureImplMixin.java",
      "language": "JAVA",
      "line": 48,
      "offset": 21,
      "length": 54,
      "code": {
        "startLine": 46,
        "length": 54,
        "offset": 114,
        "surroundingCode": "        return isSingleLineDefinition()\n                || (isSingleElementInPathAtFileRoot()\n                && (getParent().getParent() instanceof FusionPropertyBlock\n                || getParent().getParent() instanceof FusionPropertyCopy));\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "3ded44ff53829ea032f1aee7acb01be0ce7095291f16faa1f8f5c9488bb28ac2"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `parentBlock instanceof FusionBlock` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/util/NeosUtil.java",
      "language": "JAVA",
      "line": 138,
      "offset": 15,
      "length": 34,
      "code": {
        "startLine": 136,
        "length": 34,
        "offset": 160,
        "surroundingCode": "    public static String getDefiningPrototypeName(FusionPropertyAssignment assignment) {\n        PsiElement parentBlock = assignment.getParent();\n        if (!(parentBlock instanceof FusionBlock)) {\n            return null;\n        }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "4540394833a8271b3cb8d70dd8c1c78b9f4a4043b9c10e1780407512c20eb9aa"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `element.getFirstChild() instanceof FusionPath` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/structure/FusionTreeElement.java",
      "language": "JAVA",
      "line": 70,
      "offset": 17,
      "length": 45,
      "code": {
        "startLine": 68,
        "length": 45,
        "offset": 81,
        "surroundingCode": "\n        for (PsiElement element : blockElement.getChildren()) {\n            if (element.getFirstChild() instanceof FusionPath) {\n                if (element instanceof NavigatablePsiElement) {\n                    result.add(new FusionTreeElement(element.getFirstChild()));"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "4ad31128704d5c486e88a553ee063920d068ae4988aaaed07388af5b021edbec"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `e.getParent() instanceof FusionPropertyBlock` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/editor/FusionBreadcrumbsInfoProvider.java",
      "language": "JAVA",
      "line": 52,
      "offset": 41,
      "length": 44,
      "code": {
        "startLine": 50,
        "length": 44,
        "offset": 121,
        "surroundingCode": "    @Override\n    public @Nullable PsiElement getParent(@NotNull PsiElement e) {\n        if (e instanceof FusionBlock && e.getParent() instanceof FusionPropertyBlock) {\n            FusionPath path = ((FusionPropertyBlock) e.getParent()).getPath();\n            return path.getLastChild();"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "4c76f53725889343dd7d7b1d5b8b81b88967935540652dac8198bdc71ec00220"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `getElement().getFirstChild() instanceof FusionPrototypeSignature` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/structure/FusionTreeElement.java",
      "language": "JAVA",
      "line": 112,
      "offset": 20,
      "length": 64,
      "code": {
        "startLine": 110,
        "length": 64,
        "offset": 69,
        "surroundingCode": "\n        if (getElement().getFirstChild() != null\n                && getElement().getFirstChild() instanceof FusionPrototypeSignature) {\n            FusionPrototypeSignature signature = (FusionPrototypeSignature) getElement().getFirstChild();\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "4d95704ade2f097bdab94c7f65cf528a79e598ca0ff52f3f4dda17831035d500"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `getElement() instanceof FusionPropertyCopy` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/structure/FusionTreeElement.java",
      "language": "JAVA",
      "line": 133,
      "offset": 13,
      "length": 42,
      "code": {
        "startLine": 131,
        "length": 42,
        "offset": 23,
        "surroundingCode": "        }\n\n        if (getElement() instanceof FusionPropertyCopy\n                && ((FusionPropertyCopy) getElement()).isPrototypeInheritance()) {\n            return FusionIcons.PROTOTYPE;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "4e8d18807692f94445a87a645f1647a9d7564c7f9c879c00985dca564a3fcf63"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `getParent() instanceof FusionPath` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/ext/FusionCopiedPrototypeSignatureImplMixin.java",
      "language": "JAVA",
      "line": 40,
      "offset": 16,
      "length": 33,
      "code": {
        "startLine": 38,
        "length": 33,
        "offset": 65,
        "surroundingCode": "\n    protected boolean isSingleLineDefinition() {\n        return getParent() instanceof FusionPath\n                && ((FusionPath) getParent()).isPrototypeClassProperty()\n                && getParent().getParent() instanceof FusionPropertyAssignment"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "515be6b93be8b493792535f5e898f8d78c11ccfe57dcdf3dad666910323604ba"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `element instanceof FusionPrototypeSignature` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/refactoring/MovePrototypeToFile.java",
      "language": "JAVA",
      "line": 47,
      "offset": 19,
      "length": 43,
      "code": {
        "startLine": 45,
        "length": 43,
        "offset": 147,
        "surroundingCode": "    protected boolean isEnabledOnElements(PsiElement @NotNull [] psiElements) {\n        for (PsiElement element : psiElements) {\n            if (!(element instanceof FusionPrototypeSignature)) {\n                return false;\n            }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "5a7dcbbf5ce1a4bac51cefefcadd700a5d845b80008129632d725dd67830fe11"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `getParent() instanceof FusionPath` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/ext/FusionPrototypeSignatureImplMixin.java",
      "language": "JAVA",
      "line": 66,
      "offset": 16,
      "length": 33,
      "code": {
        "startLine": 64,
        "length": 33,
        "offset": 74,
        "surroundingCode": "\n    protected boolean isSingleElementInPathAtFileRoot() {\n        return getParent() instanceof FusionPath\n                && ((FusionPath) getParent()).isPrototypeSignature()\n                && getParent().getParent().getParent() instanceof FusionFile;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "5b37059925324a4c5db33841261279f5f3ce1c2a203bf40b38a87c9bc28a19fe"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `getLastChild() instanceof FusionMetaProperty` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/ext/FusionPathImplMixin.java",
      "language": "JAVA",
      "line": 43,
      "offset": 20,
      "length": 44,
      "code": {
        "startLine": 41,
        "length": 44,
        "offset": 119,
        "surroundingCode": "    public boolean isPrototypeClassProperty() {\n        if (getPrototypeSignatureList().size() == 1\n                && getLastChild() instanceof FusionMetaProperty\n                && getChildren().length == 2) {\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "638ff0902eeb2278d47070eea104d534bec8b99f311b8b012ca406149cba52b4"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `getFirstChild() instanceof FusionPrototypeSignature` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/ext/FusionPathImplMixin.java",
      "language": "JAVA",
      "line": 55,
      "offset": 13,
      "length": 51,
      "code": {
        "startLine": 53,
        "length": 51,
        "offset": 56,
        "surroundingCode": "    @Override\n    public String getName() {\n        if (getFirstChild() instanceof FusionPrototypeSignature) {\n            FusionPrototypeSignature signature = ((FusionPrototypeSignature) getFirstChild());\n            if (signature.getType() != null) {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "77fc29dc405522e0731e5f3edb26b0db4fcd384a9426fd5901fbed0ecf6686d3"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `parentElement instanceof EelMethodCall` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/eel/resolve/ref/EelMethodNameReference.java",
      "language": "JAVA",
      "line": 22,
      "offset": 13,
      "length": 38,
      "code": {
        "startLine": 20,
        "length": 38,
        "offset": 111,
        "surroundingCode": "    List<PsiElement> resolveInner() {\n        PsiElement parentElement = getElement().getParent();\n        if (parentElement instanceof EelMethodCall) {\n            if (parentElement.getPrevSibling() != null && parentElement.getPrevSibling().getPrevSibling() != null) {\n                PsiElement compositeElement = parentElement.getPrevSibling().getPrevSibling();"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "8085a1c6e5e1066ca3ad471a7d0e00ded41ecccc7ad49f864deb0f4f26cf5553"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `element instanceof FusionType` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/usages/UsagesTypeProvider.java",
      "language": "JAVA",
      "line": 41,
      "offset": 13,
      "length": 29,
      "code": {
        "startLine": 39,
        "length": 29,
        "offset": 79,
        "surroundingCode": "    public @Nullable UsageType getUsageType(PsiElement element) {\n\n        if (element instanceof FusionType) {\n            PsiElement parentElement = element.getParent();\n            if (parentElement instanceof FusionPrototypeInstance) {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "814b37728b8d695b6c76735fdf80646a209515b1019a8d0742fc14de4ee354bc"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `getParent().getParent() instanceof FusionPropertyBlock` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/ext/FusionCopiedPrototypeSignatureImplMixin.java",
      "language": "JAVA",
      "line": 35,
      "offset": 21,
      "length": 54,
      "code": {
        "startLine": 33,
        "length": 54,
        "offset": 114,
        "surroundingCode": "        return isSingleLineDefinition()\n                || (isSingleElementInPathAtFileRoot()\n                && (getParent().getParent() instanceof FusionPropertyBlock\n                || getParent().getParent() instanceof FusionPropertyCopy));\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "8920532709d15d1eefad482046390dcf5311d64be444cb82e87e1bec6956882d"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `getParent() instanceof FusionPath` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/ext/FusionPrototypeSignatureImplMixin.java",
      "language": "JAVA",
      "line": 59,
      "offset": 16,
      "length": 33,
      "code": {
        "startLine": 57,
        "length": 33,
        "offset": 65,
        "surroundingCode": "\n    protected boolean isSingleLineDefinition() {\n        return getParent() instanceof FusionPath\n                && ((FusionPath) getParent()).isPrototypeClassProperty()\n                && getParent().getParent() instanceof FusionPropertyAssignment"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "93af218f13582344a0e52a5e405fbed3224b03a174706292ea309e11da2807a1"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `currentSibling instanceof FusionPrototypeInstance` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/structure/FusionTreeElement.java",
      "language": "JAVA",
      "line": 89,
      "offset": 21,
      "length": 49,
      "code": {
        "startLine": 87,
        "length": 49,
        "offset": 103,
        "surroundingCode": "            do {\n                currentSibling = currentSibling.getNextSibling();\n                if (currentSibling instanceof FusionPrototypeInstance) {\n                    currentSibling = currentSibling.getFirstChild();\n                }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "a5a5892e79dcc582103be775381ec7016e7b991fd561298bc99cc691d8995d2e"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `getParent().getParent() instanceof FusionPropertyCopy` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/ext/FusionPrototypeSignatureImplMixin.java",
      "language": "JAVA",
      "line": 54,
      "offset": 20,
      "length": 53,
      "code": {
        "startLine": 52,
        "length": 53,
        "offset": 115,
        "surroundingCode": "    public boolean isInheritanceDefinition() {\n        return isSingleElementInPathAtFileRoot()\n                && getParent().getParent() instanceof FusionPropertyCopy;\n\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "b2681d5d09492804e41c9cc64a356e367e10769a50b2d64c09287fe82adeac5d"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "`null` is returned by the method declared as @NotNull",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/eel/psi/impl/ext/EelMethodNameImplMixin.java",
      "language": "JAVA",
      "line": 25,
      "offset": 16,
      "length": 4,
      "code": {
        "startLine": 23,
        "length": 4,
        "offset": 70,
        "surroundingCode": "    @Override\n    public PsiElement getEelFunction() {\n        return null;\n    }\n}"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "b2ee97be29992eb36294e508f642ea6cfdb514aa84d02a02c39124245213e931"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `getParent() instanceof FusionPath` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/ext/FusionCopiedPrototypeSignatureImplMixin.java",
      "language": "JAVA",
      "line": 47,
      "offset": 16,
      "length": 33,
      "code": {
        "startLine": 45,
        "length": 33,
        "offset": 74,
        "surroundingCode": "\n    protected boolean isSingleElementInPathAtFileRoot() {\n        return getParent() instanceof FusionPath\n                && ((FusionPath) getParent()).isPrototypeSignature()\n                && getParent().getParent().getParent() instanceof FusionFile;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "b3a9d845da961a482363d726d4b6a8ba9c49568c53799275299f0b2df20fa998"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Method invocation `findProperty` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/util/ComposerUtil.java",
      "language": "JAVA",
      "line": 62,
      "offset": 48,
      "length": 12,
      "code": {
        "startLine": 60,
        "length": 12,
        "offset": 127,
        "surroundingCode": "    {\n        JsonObject object = (JsonObject) composerFile.getTopLevelValue();\n        JsonProperty autoloadProperty = object.findProperty(\"autoload\");\n        Map<String,String> mappings = new HashMap<>();\n        if (autoloadProperty != null) {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "c0b9a6a921c9b684d1b4b003bde56ccc1973443be6095ead9228d26e376fd68a"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `prototypeSignature instanceof FusionPrototypeSignature` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/refactoring/MovePrototypeToFile.java",
      "language": "JAVA",
      "line": 121,
      "offset": 15,
      "length": 54,
      "code": {
        "startLine": 119,
        "length": 54,
        "offset": 112,
        "surroundingCode": "     */\n    private static boolean isTopLevelPrototype(@Nullable PsiElement prototypeSignature) {\n        if (!(prototypeSignature instanceof FusionPrototypeSignature)) {\n            return false;\n        }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "c261b892df6c91a5123f5c8bbf948e99cf2a0fa19583b2aaaa03be324cd31417"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Method invocation `getPath` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/editor/FusionBreadcrumbsInfoProvider.java",
      "language": "JAVA",
      "line": 63,
      "offset": 74,
      "length": 7,
      "code": {
        "startLine": 61,
        "length": 7,
        "offset": 124,
        "surroundingCode": "\n        if (e instanceof FusionAssignmentValue) {\n            FusionPath path = ((FusionPropertyAssignment) e.getParent()).getPath();\n            return path.getLastChild();\n        }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "c28775aea11ae9462628e7421e2685a0587ec3a52085ef8af9ad118ace1024d8"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Method invocation `getText` may produce `NullPointerException`",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/util/ComposerUtil.java",
      "language": "JAVA",
      "line": 80,
      "offset": 78,
      "length": 7,
      "code": {
        "startLine": 78,
        "length": 7,
        "offset": 198,
        "surroundingCode": "                if (psrObject != null) {\n                    for (JsonProperty property : psrObject.getPropertyList()) {\n                        mappings.put(property.getName(), property.getValue().getText());\n                    }\n                }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "c56e7fa9acf3630cb7f1a6ca2360f471ccfe47b1d08ab8011ec0239a388accad"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Argument `fileByURL` might be null",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/xliff/XliffSchemaProvider.java",
      "language": "JAVA",
      "line": 22,
      "offset": 57,
      "length": 9,
      "code": {
        "startLine": 20,
        "length": 9,
        "offset": 240,
        "surroundingCode": "        final URL resource = XliffSchemaProvider.class.getResource(\"/de/vette/idea/neos/xsd/xliff/xliff12.xsd\");\n        final VirtualFile fileByURL = VfsUtil.findFileByURL(resource);\n        PsiFile result = baseFile.getManager().findFile(fileByURL);\n        if (result instanceof XmlFile) {\n            return (XmlFile)result.copy();"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "c6d6409814b0fda136711acc601de773b4eb1dfb5e505ee32c09750643d1f491"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `resultPrototype instanceof FusionPrototypeSignature` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/resolve/ResolveEngine.java",
      "language": "JAVA",
      "line": 141,
      "offset": 17,
      "length": 51,
      "code": {
        "startLine": 139,
        "length": 51,
        "offset": 158,
        "surroundingCode": "        // If one of the results is a prototype inheritance, return it as the only result\n        for (PsiElement resultPrototype : result) {\n            if (resultPrototype instanceof FusionPrototypeSignature\n                    && ((FusionPrototypeSignature)resultPrototype).isInheritanceDefinition()) {\n                result.clear();"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "ca2232b3aca2ab3faa589cc184f3cef0eb17fc28f27c8e83db62de5d91964fc6"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `el instanceof FusionType` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/annotators/NodeTypeLineMarkerProvider.java",
      "language": "JAVA",
      "line": 45,
      "offset": 19,
      "length": 24,
      "code": {
        "startLine": 43,
        "length": 24,
        "offset": 201,
        "surroundingCode": "    public void collectSlowLineMarkers(@NotNull List<? extends PsiElement> elements, @NotNull Collection<? super LineMarkerInfo<?>> result) {\n        for (PsiElement el : elements) {\n            if (!(el instanceof FusionType)\n                    || !(el.getParent() instanceof FusionPrototypeSignature)\n                    || (el.getParent().getParent().getParent() instanceof FusionPropertyDeletion)) {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "d7fce53ac54421062adebac316c68428527813e348506241aab18785c24d5461"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `el.getParent().getParent().getParent() instanceof FusionPropertyDeletion` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/annotators/NodeTypeLineMarkerProvider.java",
      "language": "JAVA",
      "line": 47,
      "offset": 25,
      "length": 72,
      "code": {
        "startLine": 45,
        "length": 72,
        "offset": 145,
        "surroundingCode": "            if (!(el instanceof FusionType)\n                    || !(el.getParent() instanceof FusionPrototypeSignature)\n                    || (el.getParent().getParent().getParent() instanceof FusionPropertyDeletion)) {\n                continue;\n            }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "e09d5c711ac173c8fd704b869608f37416232e519a6636eeb096a95fedbd2dbe"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `getParent().getParent() instanceof FusionPropertyAssignment` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/ext/FusionPrototypeSignatureImplMixin.java",
      "language": "JAVA",
      "line": 61,
      "offset": 20,
      "length": 59,
      "code": {
        "startLine": 59,
        "length": 59,
        "offset": 141,
        "surroundingCode": "        return getParent() instanceof FusionPath\n                && ((FusionPath) getParent()).isPrototypeClassProperty()\n                && getParent().getParent() instanceof FusionPropertyAssignment\n                && getParent().getParent().getParent() instanceof FusionFile;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "e47f4e82ba4c9cc6d76c6b66a2cdacfd979d53a51cd40f757408c7f4a3cc378c"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Argument `this.getRemoteSource()` might be null",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/config/yaml/schema/NodeTypeYamlSchemaProvider.java",
      "language": "JAVA",
      "line": 37,
      "offset": 43,
      "length": 22,
      "code": {
        "startLine": 35,
        "length": 22,
        "offset": 107,
        "surroundingCode": "    @Override\n    public @Nullable VirtualFile getSchemaFile() {\n        return JsonFileResolver.urlToFile(this.getRemoteSource());\n    }\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "e7f92ce21102eca72a7c775695d176bb8304db326bd0e334085e897a41a9d1b9"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `parent instanceof FusionPropertyCopy` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/util/NeosUtil.java",
      "language": "JAVA",
      "line": 143,
      "offset": 13,
      "length": 36,
      "code": {
        "startLine": 141,
        "length": 36,
        "offset": 66,
        "surroundingCode": "\n        PsiElement parent = parentBlock.getParent();\n        if (parent instanceof FusionPropertyCopy) {\n            FusionPropertyCopy copy = (FusionPropertyCopy) parent;\n            if (!copy.isPrototypeInheritance()) {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "e9bf276e7fbfd2d51f45b9d41a9e4d146dab52a677ca4eb0c59cf6c4e4f1379c"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Condition `getParent().getParent() instanceof FusionPropertyAssignment` is redundant and can be replaced with a null check",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/ext/FusionCopiedPrototypeSignatureImplMixin.java",
      "language": "JAVA",
      "line": 42,
      "offset": 20,
      "length": 59,
      "code": {
        "startLine": 40,
        "length": 59,
        "offset": 141,
        "surroundingCode": "        return getParent() instanceof FusionPath\n                && ((FusionPath) getParent()).isPrototypeClassProperty()\n                && getParent().getParent() instanceof FusionPropertyAssignment\n                && getParent().getParent().getParent() instanceof FusionFile;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "fe6f13e5257bb5cfe3e285567a6cdee6f12bb0d7191ecd09f741019da6d01392"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Deprecated API usage",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'getStubType()' is deprecated",
  "detailsInfo": "Reports usages of deprecated classes, fields, and methods. A quick-fix is available to automatically convert the deprecated usage, when the necessary information can be extracted from the Javadoc of the deprecated member.\n\n**Example:**\n\n\n      class Interesting {\n\n        /**\n         * @deprecated Use {@link #newHotness()} instead\n         */\n        @Deprecated\n        public void oldAndBusted() {}\n\n        public void newHotness() {}\n      }\n      class ElseWhere {\n        void x(Interesting i) {\n          i.oldAndBusted(); // deprecated warning here\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Interesting {\n\n        /**\n         * @deprecated Use {@link #newHotness()} instead\n         */\n        @Deprecated\n        public void oldAndBusted() {}\n\n        public void newHotness() {}\n      }\n      class ElseWhere {\n        void x(Interesting i) {\n          i.newHotness();\n        }\n      }\n\nBy default, the inspection doesn't produce a warning if it's impossible or hard to avoid it. For example,\nthe following code won't be reported:\n\n\n      abstract class A { //library code\n         @Deprecated\n         abstract void m();\n      }\n      class B extends A { //project code\n         @Override\n         void m() {\n            //doSmth;\n         }\n      }\n\nConfigure the inspection:\n\n\nUse the options to disable this inspection inside deprecated members,\noverrides of abstract deprecated methods, non-static import statements, methods of deprecated classes, or same top-level classes.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/stubs/FusionPrototypeSignatureStub.java",
      "language": "JAVA",
      "line": 47,
      "offset": 64,
      "length": 11,
      "code": {
        "startLine": 45,
        "length": 11,
        "offset": 177,
        "surroundingCode": "        @Override\n        public FusionPrototypeSignature createPsi(@NotNull FusionPrototypeSignatureStub stub) {\n            return new FusionPrototypeSignatureImpl(stub, stub.getStubType());\n        }\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "Deprecation"
  },
  "hash": "426340c5d12ab954c1cb7b95d6000691e0bd00118f02ec79afdc39b0946d78e4"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Deprecated API usage",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'isPopupPlace(java.lang.@org.jetbrains.annotations.NotNull String)' is deprecated",
  "detailsInfo": "Reports usages of deprecated classes, fields, and methods. A quick-fix is available to automatically convert the deprecated usage, when the necessary information can be extracted from the Javadoc of the deprecated member.\n\n**Example:**\n\n\n      class Interesting {\n\n        /**\n         * @deprecated Use {@link #newHotness()} instead\n         */\n        @Deprecated\n        public void oldAndBusted() {}\n\n        public void newHotness() {}\n      }\n      class ElseWhere {\n        void x(Interesting i) {\n          i.oldAndBusted(); // deprecated warning here\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Interesting {\n\n        /**\n         * @deprecated Use {@link #newHotness()} instead\n         */\n        @Deprecated\n        public void oldAndBusted() {}\n\n        public void newHotness() {}\n      }\n      class ElseWhere {\n        void x(Interesting i) {\n          i.newHotness();\n        }\n      }\n\nBy default, the inspection doesn't produce a warning if it's impossible or hard to avoid it. For example,\nthe following code won't be reported:\n\n\n      abstract class A { //library code\n         @Deprecated\n         abstract void m();\n      }\n      class B extends A { //project code\n         @Override\n         void m() {\n            //doSmth;\n         }\n      }\n\nConfigure the inspection:\n\n\nUse the options to disable this inspection inside deprecated members,\noverrides of abstract deprecated methods, non-static import statements, methods of deprecated classes, or same top-level classes.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/actions/TranslateNodeTypeAction.java",
      "language": "JAVA",
      "line": 49,
      "offset": 75,
      "length": 12,
      "code": {
        "startLine": 47,
        "length": 12,
        "offset": 85,
        "surroundingCode": "        }\n\n        if (!Settings.getInstance(project).pluginEnabled || !ActionPlaces.isPopupPlace(e.getPlace())) {\n            e.getPresentation().setEnabledAndVisible(false);\n            return;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "Deprecation"
  },
  "hash": "92ddfac7ff47cc1bc30759bba4c84631f5590c17c5ed68b3093241c6711e56d2"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Deprecated API usage",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'createSingleLocalFileDescriptor()' is deprecated",
  "detailsInfo": "Reports usages of deprecated classes, fields, and methods. A quick-fix is available to automatically convert the deprecated usage, when the necessary information can be extracted from the Javadoc of the deprecated member.\n\n**Example:**\n\n\n      class Interesting {\n\n        /**\n         * @deprecated Use {@link #newHotness()} instead\n         */\n        @Deprecated\n        public void oldAndBusted() {}\n\n        public void newHotness() {}\n      }\n      class ElseWhere {\n        void x(Interesting i) {\n          i.oldAndBusted(); // deprecated warning here\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Interesting {\n\n        /**\n         * @deprecated Use {@link #newHotness()} instead\n         */\n        @Deprecated\n        public void oldAndBusted() {}\n\n        public void newHotness() {}\n      }\n      class ElseWhere {\n        void x(Interesting i) {\n          i.newHotness();\n        }\n      }\n\nBy default, the inspection doesn't produce a warning if it's impossible or hard to avoid it. For example,\nthe following code won't be reported:\n\n\n      abstract class A { //library code\n         @Deprecated\n         abstract void m();\n      }\n      class B extends A { //project code\n         @Override\n         void m() {\n            //doSmth;\n         }\n      }\n\nConfigure the inspection:\n\n\nUse the options to disable this inspection inside deprecated members,\noverrides of abstract deprecated methods, non-static import statements, methods of deprecated classes, or same top-level classes.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/refactoring/MovePrototypeDialog.java",
      "language": "JAVA",
      "line": 274,
      "offset": 73,
      "length": 31,
      "code": {
        "startLine": 272,
        "length": 31,
        "offset": 267,
        "surroundingCode": "        field.getChildComponent().setModel(new DefaultComboBoxModel<String>(items.toArray(String[]::new)));\n        String title = FusionBundle.message(\"refactoring.move.prototype.target.file\");\n        FileChooserDescriptor descriptor = FileChooserDescriptorFactory.createSingleLocalFileDescriptor()\n                .withFileFilter((file) -> file.getFileType() instanceof LanguageFileType && ((LanguageFileType) file.getFileType()).getLanguage().isKindOf(FusionLanguage.INSTANCE))\n                .withRoots(ProjectRootManager.getInstance(myProject).getContentRoots())"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "Deprecation"
  },
  "hash": "d65147703310637bb124e6048707dbf00a7625d8a20314d9c89555fe3624c853"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'Move to' is not properly capitalized. It should have title capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/refactoring/MovePrototypeDialog.java",
      "language": "JAVA",
      "line": 273,
      "offset": 24,
      "length": 62,
      "code": {
        "startLine": 271,
        "length": 62,
        "offset": 173,
        "surroundingCode": "        appendPossibleTargetFiles(items);\n        field.getChildComponent().setModel(new DefaultComboBoxModel<String>(items.toArray(String[]::new)));\n        String title = FusionBundle.message(\"refactoring.move.prototype.target.file\");\n        FileChooserDescriptor descriptor = FileChooserDescriptorFactory.createSingleLocalFileDescriptor()\n                .withFileFilter((file) -> file.getFileType() instanceof LanguageFileType && ((LanguageFileType) file.getFileType()).getLanguage().isKindOf(FusionLanguage.INSTANCE))"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "0730fdaf3d10af519c7689b040a033bd95732eb01316199889cb807921a99d29"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'Single Line Comment' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/pages/FusionColorSettingsPage.java",
      "language": "JAVA",
      "line": 40,
      "offset": 38,
      "length": 21,
      "code": {
        "startLine": 38,
        "length": 21,
        "offset": 128,
        "surroundingCode": "\n    private static final AttributesDescriptor[] DESCRIPTORS = new AttributesDescriptor[]{\n            new AttributesDescriptor(\"Single Line Comment\", FusionHighlightingColors.SINGLE_LINE_COMMENT),\n            new AttributesDescriptor(\"Block Comment\", FusionHighlightingColors.BLOCK_COMMENT),\n            new AttributesDescriptor(\"Declaration\", FusionHighlightingColors.DECLARATION),"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "0909c56844b050bf1bf66c9b5a56e09da6bf24a63badae783458e03102e64ed5"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'File types' is not properly capitalized. It should have title capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/actions/TranslateNodeTypeAction.java",
      "language": "JAVA",
      "line": 154,
      "offset": 84,
      "length": 12,
      "code": {
        "startLine": 152,
        "length": 12,
        "offset": 225,
        "surroundingCode": "                    @Override\n                    public void actionPerformed(@NotNull AnActionEvent e, @NotNull Notification notification) {\n                        ShowSettingsUtil.getInstance().showSettingsDialog(project, \"File types\");\n\n                    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "0a0095d2c7d0d410d6adda8c604b2fc76171de639ea43dd91c959a37983f02f0"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'Boolean and Null Values' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/pages/FusionColorSettingsPage.java",
      "language": "JAVA",
      "line": 49,
      "offset": 38,
      "length": 25,
      "code": {
        "startLine": 47,
        "length": 25,
        "offset": 215,
        "surroundingCode": "            new AttributesDescriptor(\"String\", FusionHighlightingColors.STRING),\n            new AttributesDescriptor(\"Escaped String\", FusionHighlightingColors.STRING_ESCAPED),\n            new AttributesDescriptor(\"Boolean and Null Values\", FusionHighlightingColors.VALUE),\n            new AttributesDescriptor(\"Prototype\", FusionHighlightingColors.PROTOTYPE),\n            new AttributesDescriptor(\"Path\", FusionHighlightingColors.PATH),"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "0ed700f04d2961481349ad4af9f142ff84c6ac74a4074ecc7c00b70414618fea"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'Empty File' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/actions/CreateFusionFile.java",
      "language": "JAVA",
      "line": 22,
      "offset": 51,
      "length": 12,
      "code": {
        "startLine": 20,
        "length": 12,
        "offset": 184,
        "surroundingCode": "    @Override\n    protected void buildDialog(Project project, PsiDirectory directory, CreateFileFromTemplateDialog.Builder builder) {\n        builder.setTitle(NEW_FUSION_FILE).addKind(\"Empty File\", FusionIcons.FILE, \"Fusion File\");\n        builder.setTitle(NEW_FUSION_FILE).addKind(\"Content Prototype\", FusionIcons.PROTOTYPE, \"Fusion Content Prototype\");\n        builder.setTitle(NEW_FUSION_FILE).addKind(\"Component Prototype\", FusionIcons.PROTOTYPE, \"Fusion Component Prototype\");"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "11d60bb9ca7aceb9d6fb10d6f107b70d75060768abf75c89f5d95d179158949e"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'XML Localization Interchange File Format' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/xliff/XliffFileType.java",
      "language": "JAVA",
      "line": 27,
      "offset": 16,
      "length": 42,
      "code": {
        "startLine": 25,
        "length": 42,
        "offset": 94,
        "surroundingCode": "    @Override\n    public @NlsContexts.Label @NotNull String getDescription() {\n        return \"XML Localization Interchange File Format\";\n    }\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "26fc1433bc32501e4d0a414dfaee340a17090099e5361044f194302b4c74cfbf"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'Escaped String' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/pages/FusionColorSettingsPage.java",
      "language": "JAVA",
      "line": 48,
      "offset": 38,
      "length": 16,
      "code": {
        "startLine": 46,
        "length": 16,
        "offset": 199,
        "surroundingCode": "            new AttributesDescriptor(\"Number\", FusionHighlightingColors.NUMBER),\n            new AttributesDescriptor(\"String\", FusionHighlightingColors.STRING),\n            new AttributesDescriptor(\"Escaped String\", FusionHighlightingColors.STRING_ESCAPED),\n            new AttributesDescriptor(\"Boolean and Null Values\", FusionHighlightingColors.VALUE),\n            new AttributesDescriptor(\"Prototype\", FusionHighlightingColors.PROTOTYPE),"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "39b7984f0252c0b7cca582f424b5042b3b2032fbec75b2b7cd922e33fb99d20f"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'Assignment Operators' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/formatter/FusionLanguageCodeStyleSettingsProvider.java",
      "language": "JAVA",
      "line": 41,
      "offset": 80,
      "length": 22,
      "code": {
        "startLine": 39,
        "length": 22,
        "offset": 219,
        "surroundingCode": "        if (settingsType == SettingsType.SPACING_SETTINGS) {\n            consumer.showStandardOptions(\"SPACE_AROUND_ASSIGNMENT_OPERATORS\");\n            consumer.renameStandardOption(\"SPACE_AROUND_ASSIGNMENT_OPERATORS\", \"Assignment Operators\");\n            consumer.showStandardOptions(\"SPACES_BEFORE_LEFT_BRACE\");\n            consumer.showStandardOptions(\"SPACE_AFTER_COMMA\");"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "39fc09782bf3295bdf92739d8104b81f7704bcffe86bf87eeb40d468d2e566ea"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'Neos Plugin' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/util/IdeHelper.java",
      "language": "JAVA",
      "line": 33,
      "offset": 69,
      "length": 13,
      "code": {
        "startLine": 31,
        "length": 13,
        "offset": 137,
        "surroundingCode": "\n    public static void notifyEnableMessage(final Project project) {\n        Notification notification = new Notification(\"Neos Plugin\", \"Neos Plugin\", \"This looks like a Neos CMS project. You'll need to enable the plugin for this project in order to use all provided features.\", NotificationType.INFORMATION);\n        notification.setTitle(\"Neos CMS Support\");\n        notification.setIcon(NeosIcons.NODE_TYPE);"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "47ba31112564758d801b72ae9977f3c056dcf5c8325fc8e65c9b0d628a007d11"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'Move prototypes to file ''{0}''' is not properly capitalized. It should have title capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/refactoring/MovePrototypeProcessor.java",
      "language": "JAVA",
      "line": 224,
      "offset": 16,
      "length": 64,
      "code": {
        "startLine": 222,
        "length": 64,
        "offset": 190,
        "surroundingCode": "    protected @NotNull @NlsContexts.Command String getCommandName() {\n        String path = myTargetFile != null ? myTargetFile.getVirtualFile().getPath() : myTargetFilePath;\n        return FusionBundle.message(\"refactoring.move.prototype.move.to\", path);\n    }\n}"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "5529126f47a4798a0e19b435d46927783b84a19a012b6d533f83af70e4a1a6be"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'EEL Function' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/pages/FusionColorSettingsPage.java",
      "language": "JAVA",
      "line": 59,
      "offset": 38,
      "length": 14,
      "code": {
        "startLine": 57,
        "length": 14,
        "offset": 225,
        "surroundingCode": "            new AttributesDescriptor(\"EEL Wrapper\", FusionHighlightingColors.EEL_WRAPPER),\n            new AttributesDescriptor(\"EEL Identifier\", FusionHighlightingColors.EEL_IDENTIFIER),\n            new AttributesDescriptor(\"EEL Function\", FusionHighlightingColors.EEL_FUNCTION),\n            new AttributesDescriptor(\"EEL Operator\", FusionHighlightingColors.EEL_OPERATOR),\n            new AttributesDescriptor(\"DSL Identifier\", FusionHighlightingColors.DSL_IDENTIFIER)"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "569e57d880528c6f04d8f8f81ddb3676d1451d703e98c6f0fba6a831f5aec134"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'Unset Operator' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/pages/FusionColorSettingsPage.java",
      "language": "JAVA",
      "line": 55,
      "offset": 38,
      "length": 16,
      "code": {
        "startLine": 53,
        "length": 16,
        "offset": 235,
        "surroundingCode": "            new AttributesDescriptor(\"Parentheses\", FusionHighlightingColors.PARENTHESES),\n            new AttributesDescriptor(\"Assignment Operator\", FusionHighlightingColors.ASSIGNMENT_OPERATOR),\n            new AttributesDescriptor(\"Unset Operator\", FusionHighlightingColors.UNSET_OPERATOR),\n            new AttributesDescriptor(\"Copy Operator\", FusionHighlightingColors.COPY_OPERATOR),\n            new AttributesDescriptor(\"EEL Wrapper\", FusionHighlightingColors.EEL_WRAPPER),"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "5782daf6a5d3f1e70e780d372a90943ac466ef066716caf370debb4002cadb6c"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'Content Prototype' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/actions/CreateFusionFile.java",
      "language": "JAVA",
      "line": 23,
      "offset": 51,
      "length": 19,
      "code": {
        "startLine": 21,
        "length": 19,
        "offset": 268,
        "surroundingCode": "    protected void buildDialog(Project project, PsiDirectory directory, CreateFileFromTemplateDialog.Builder builder) {\n        builder.setTitle(NEW_FUSION_FILE).addKind(\"Empty File\", FusionIcons.FILE, \"Fusion File\");\n        builder.setTitle(NEW_FUSION_FILE).addKind(\"Content Prototype\", FusionIcons.PROTOTYPE, \"Fusion Content Prototype\");\n        builder.setTitle(NEW_FUSION_FILE).addKind(\"Component Prototype\", FusionIcons.PROTOTYPE, \"Fusion Component Prototype\");\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "5a4ebfbbaa4bc60150f93fe4328b2f6befe20f5c38d6cc1e33039bad9a7b19a3"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'Block Comment' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/pages/FusionColorSettingsPage.java",
      "language": "JAVA",
      "line": 41,
      "offset": 38,
      "length": 15,
      "code": {
        "startLine": 39,
        "length": 15,
        "offset": 234,
        "surroundingCode": "    private static final AttributesDescriptor[] DESCRIPTORS = new AttributesDescriptor[]{\n            new AttributesDescriptor(\"Single Line Comment\", FusionHighlightingColors.SINGLE_LINE_COMMENT),\n            new AttributesDescriptor(\"Block Comment\", FusionHighlightingColors.BLOCK_COMMENT),\n            new AttributesDescriptor(\"Declaration\", FusionHighlightingColors.DECLARATION),\n            new AttributesDescriptor(\"Include Path\", FusionHighlightingColors.INCLUDE_PATH),"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "5c51c6146abe7307c3819464c866f1f800f3efd13073c63970358e13108a4418"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'EEL Wrapper' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/pages/FusionColorSettingsPage.java",
      "language": "JAVA",
      "line": 57,
      "offset": 38,
      "length": 13,
      "code": {
        "startLine": 55,
        "length": 13,
        "offset": 229,
        "surroundingCode": "            new AttributesDescriptor(\"Unset Operator\", FusionHighlightingColors.UNSET_OPERATOR),\n            new AttributesDescriptor(\"Copy Operator\", FusionHighlightingColors.COPY_OPERATOR),\n            new AttributesDescriptor(\"EEL Wrapper\", FusionHighlightingColors.EEL_WRAPPER),\n            new AttributesDescriptor(\"EEL Identifier\", FusionHighlightingColors.EEL_IDENTIFIER),\n            new AttributesDescriptor(\"EEL Function\", FusionHighlightingColors.EEL_FUNCTION),"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "6c41fecd9e621f7484a61b105d53f0f5c10a58f5f8800db40e7a58ed6fe016f6"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'Neos Fusion' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/livetemplates/FusionContext.java",
      "language": "JAVA",
      "line": 11,
      "offset": 15,
      "length": 13,
      "code": {
        "startLine": 9,
        "length": 13,
        "offset": 44,
        "surroundingCode": "\n    public FusionContext() {\n        super(\"Neos Fusion\");\n    }\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "6e2d4a44b8772647d10f5bd4e354a2b8d850c699f42904c16745c2fbf034bbe5"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'EEL Identifier' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/pages/FusionColorSettingsPage.java",
      "language": "JAVA",
      "line": 58,
      "offset": 38,
      "length": 16,
      "code": {
        "startLine": 56,
        "length": 16,
        "offset": 223,
        "surroundingCode": "            new AttributesDescriptor(\"Copy Operator\", FusionHighlightingColors.COPY_OPERATOR),\n            new AttributesDescriptor(\"EEL Wrapper\", FusionHighlightingColors.EEL_WRAPPER),\n            new AttributesDescriptor(\"EEL Identifier\", FusionHighlightingColors.EEL_IDENTIFIER),\n            new AttributesDescriptor(\"EEL Function\", FusionHighlightingColors.EEL_FUNCTION),\n            new AttributesDescriptor(\"EEL Operator\", FusionHighlightingColors.EEL_OPERATOR),"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "7458f8273a7bbcf41797cfffa64dc3d88876d84a5f58e1f36f64079b673084fd"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'Copy Operator' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/pages/FusionColorSettingsPage.java",
      "language": "JAVA",
      "line": 56,
      "offset": 38,
      "length": 15,
      "code": {
        "startLine": 54,
        "length": 15,
        "offset": 241,
        "surroundingCode": "            new AttributesDescriptor(\"Assignment Operator\", FusionHighlightingColors.ASSIGNMENT_OPERATOR),\n            new AttributesDescriptor(\"Unset Operator\", FusionHighlightingColors.UNSET_OPERATOR),\n            new AttributesDescriptor(\"Copy Operator\", FusionHighlightingColors.COPY_OPERATOR),\n            new AttributesDescriptor(\"EEL Wrapper\", FusionHighlightingColors.EEL_WRAPPER),\n            new AttributesDescriptor(\"EEL Identifier\", FusionHighlightingColors.EEL_IDENTIFIER),"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "7a2368f6767f30be6e22dcacf88316986c17ec13cbcf2b5d55807e7211bfe05c"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'The following data is collected to help improve the plugin experience: Plugin Version, Java Vendor, Java Version, Java Runtime Version, OS Name, OS Version, OS Arch, Application Name, Last Action and the stacktrace.' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/errorReporting/SentryErrorReporter.java",
      "language": "JAVA",
      "line": 96,
      "offset": 16,
      "length": 49,
      "code": {
        "startLine": 94,
        "length": 49,
        "offset": 115,
        "surroundingCode": "    @Override\n    public @Nullable @NlsContexts.DetailedDescription String getPrivacyNoticeText() {\n        return ErrorReportBundle.message(\"report.error.privacy\");\n    }\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "7cfbe9fdaffdd36205a0f49fc33f5ec35ade4525897609cfbc7df969a626c28f"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'Empty File' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/actions/CreateXliffFile.java",
      "language": "JAVA",
      "line": 24,
      "offset": 50,
      "length": 12,
      "code": {
        "startLine": 22,
        "length": 12,
        "offset": 183,
        "surroundingCode": "    @Override\n    protected void buildDialog(Project project, PsiDirectory directory, CreateFileFromTemplateDialog.Builder builder) {\n        builder.setTitle(NEW_XLIFF_FILE).addKind(\"Empty File\", XliffIcons.XLIFF_FILE, \"XLIFF File\");\n    }\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "81fb6c1f2166f0ed19c7bb4f94c3bcecc1eee84770dcb1d9409af95a0ae7d6eb"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'Object Type' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/pages/FusionColorSettingsPage.java",
      "language": "JAVA",
      "line": 44,
      "offset": 38,
      "length": 13,
      "code": {
        "startLine": 42,
        "length": 13,
        "offset": 221,
        "surroundingCode": "            new AttributesDescriptor(\"Declaration\", FusionHighlightingColors.DECLARATION),\n            new AttributesDescriptor(\"Include Path\", FusionHighlightingColors.INCLUDE_PATH),\n            new AttributesDescriptor(\"Object Type\", FusionHighlightingColors.OBJECT_TYPE),\n            new AttributesDescriptor(\"Meta Property\", FusionHighlightingColors.META_PROPERTY),\n            new AttributesDescriptor(\"Number\", FusionHighlightingColors.NUMBER),"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "86d9bccfd4729660e9ccd4db547b627d584a1ed6274f5ef3ed60e3b3a8c896d5"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'Component Prototype' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/actions/CreateFusionFile.java",
      "language": "JAVA",
      "line": 24,
      "offset": 51,
      "length": 21,
      "code": {
        "startLine": 22,
        "length": 21,
        "offset": 271,
        "surroundingCode": "        builder.setTitle(NEW_FUSION_FILE).addKind(\"Empty File\", FusionIcons.FILE, \"Fusion File\");\n        builder.setTitle(NEW_FUSION_FILE).addKind(\"Content Prototype\", FusionIcons.PROTOTYPE, \"Fusion Content Prototype\");\n        builder.setTitle(NEW_FUSION_FILE).addKind(\"Component Prototype\", FusionIcons.PROTOTYPE, \"Fusion Component Prototype\");\n    }\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "91fbd53af77ce83692813b4cfd85499662bc65fb79253365eefbe374ef3dc79b"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'Create file ''{0}''' is not properly capitalized. It should have title capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/refactoring/MovePrototypeProcessor.java",
      "language": "JAVA",
      "line": 95,
      "offset": 12,
      "length": 72,
      "code": {
        "startLine": 93,
        "length": 72,
        "offset": 196,
        "surroundingCode": "                CommonRefactoringUtil.showErrorMessage(myTitle, FusionBundle.message(\"refactoring.move.prototype.error.creating.file\", e.getMessage()),  null, myProject);\n            }\n        }, FusionBundle.message(\"refactoring.move.prototype.create.file\", fileName), \"movePrototypeRefactoring\");\n\n        if (fileRef.isNull()) {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "a88856371dfb582452292c2fd38b63ce47ec16191d2b71250a39728b3b2b08db"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'DSL Identifier' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/pages/FusionColorSettingsPage.java",
      "language": "JAVA",
      "line": 61,
      "offset": 38,
      "length": 16,
      "code": {
        "startLine": 59,
        "length": 16,
        "offset": 223,
        "surroundingCode": "            new AttributesDescriptor(\"EEL Function\", FusionHighlightingColors.EEL_FUNCTION),\n            new AttributesDescriptor(\"EEL Operator\", FusionHighlightingColors.EEL_OPERATOR),\n            new AttributesDescriptor(\"DSL Identifier\", FusionHighlightingColors.DSL_IDENTIFIER)\n    };\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "b16d66ba5ef4da4865fbcfb8c3ef1724aa8b0738a7b3dea5f5205b21c4891bab"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'Meta Property' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/pages/FusionColorSettingsPage.java",
      "language": "JAVA",
      "line": 45,
      "offset": 38,
      "length": 15,
      "code": {
        "startLine": 43,
        "length": 15,
        "offset": 221,
        "surroundingCode": "            new AttributesDescriptor(\"Include Path\", FusionHighlightingColors.INCLUDE_PATH),\n            new AttributesDescriptor(\"Object Type\", FusionHighlightingColors.OBJECT_TYPE),\n            new AttributesDescriptor(\"Meta Property\", FusionHighlightingColors.META_PROPERTY),\n            new AttributesDescriptor(\"Number\", FusionHighlightingColors.NUMBER),\n            new AttributesDescriptor(\"String\", FusionHighlightingColors.STRING),"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "be589105d1b6b381413f9d8f6244444223ee4f5896b1747c547b47527be6b103"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'Include Path' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/pages/FusionColorSettingsPage.java",
      "language": "JAVA",
      "line": 43,
      "offset": 38,
      "length": 14,
      "code": {
        "startLine": 41,
        "length": 14,
        "offset": 223,
        "surroundingCode": "            new AttributesDescriptor(\"Block Comment\", FusionHighlightingColors.BLOCK_COMMENT),\n            new AttributesDescriptor(\"Declaration\", FusionHighlightingColors.DECLARATION),\n            new AttributesDescriptor(\"Include Path\", FusionHighlightingColors.INCLUDE_PATH),\n            new AttributesDescriptor(\"Object Type\", FusionHighlightingColors.OBJECT_TYPE),\n            new AttributesDescriptor(\"Meta Property\", FusionHighlightingColors.META_PROPERTY),"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "cd7fd0f37df01496245f52180ab40b8d414c1ff7aa14426e1bfab8d86fc2f221"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'Empty File' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/actions/CreateNodeTypeDefinition.java",
      "language": "JAVA",
      "line": 59,
      "offset": 60,
      "length": 12,
      "code": {
        "startLine": 57,
        "length": 12,
        "offset": 193,
        "surroundingCode": "    @Override\n    protected void buildDialog(Project project, PsiDirectory directory, CreateFileFromTemplateDialog.Builder builder) {\n        builder.setTitle(NEW_NODE_TYPE_DEFINITION).addKind(\"Empty File\", NeosIcons.NODE_TYPE, NODE_TYPE_TEMPLATE_NAME);\n        builder.setTitle(NEW_NODE_TYPE_DEFINITION).addKind(\"Document\", NeosIcons.NODE_TYPE, DOCUMENT_NODE_TYPE_TEMPLATE_NAME);\n        builder.setTitle(NEW_NODE_TYPE_DEFINITION).addKind(\"Content\", NeosIcons.NODE_TYPE, CONTENT_NODE_TYPE_TEMPLATE_NAME);"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "ce55704e55eee29d6949d6dd2124ddc02bb21095aa7a269a91c3f55d81d7a439"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'Neos Eel' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/eel/EelFileType.java",
      "language": "JAVA",
      "line": 28,
      "offset": 16,
      "length": 10,
      "code": {
        "startLine": 26,
        "length": 10,
        "offset": 94,
        "surroundingCode": "    @Override\n    public @NlsContexts.Label @NotNull String getDescription() {\n        return \"Neos Eel\";\n    }\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "db8388a28fc7eabc4a7ca20745c25134e81027d47a3221fa798b91b16d1d96ea"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'Assignment Operator' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/pages/FusionColorSettingsPage.java",
      "language": "JAVA",
      "line": 54,
      "offset": 38,
      "length": 21,
      "code": {
        "startLine": 52,
        "length": 21,
        "offset": 209,
        "surroundingCode": "            new AttributesDescriptor(\"Braces\", FusionHighlightingColors.BRACES),\n            new AttributesDescriptor(\"Parentheses\", FusionHighlightingColors.PARENTHESES),\n            new AttributesDescriptor(\"Assignment Operator\", FusionHighlightingColors.ASSIGNMENT_OPERATOR),\n            new AttributesDescriptor(\"Unset Operator\", FusionHighlightingColors.UNSET_OPERATOR),\n            new AttributesDescriptor(\"Copy Operator\", FusionHighlightingColors.COPY_OPERATOR),"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "dc36691fcd92b965063ad583e336ce911b64f84088a3d76e11eca93613ad0b77"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'EEL Operator' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/pages/FusionColorSettingsPage.java",
      "language": "JAVA",
      "line": 60,
      "offset": 38,
      "length": 14,
      "code": {
        "startLine": 58,
        "length": 14,
        "offset": 227,
        "surroundingCode": "            new AttributesDescriptor(\"EEL Identifier\", FusionHighlightingColors.EEL_IDENTIFIER),\n            new AttributesDescriptor(\"EEL Function\", FusionHighlightingColors.EEL_FUNCTION),\n            new AttributesDescriptor(\"EEL Operator\", FusionHighlightingColors.EEL_OPERATOR),\n            new AttributesDescriptor(\"DSL Identifier\", FusionHighlightingColors.DSL_IDENTIFIER)\n    };"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "e935cf7e280d706bd44d80fa9118aba0a62e6d49e3418f663aeeffabc7364560"
},{
  "tool": "Code Inspection",
  "category": "Internationalization",
  "type": "Incorrect string capitalization",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "String 'Neos Afx' is not properly capitalized. It should have sentence capitalization",
  "detailsInfo": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/afx/AfxFileType.java",
      "language": "JAVA",
      "line": 28,
      "offset": 16,
      "length": 10,
      "code": {
        "startLine": 26,
        "length": 10,
        "offset": 94,
        "surroundingCode": "    @Override\n    public @NlsContexts.Label @NotNull String getDescription() {\n        return \"Neos Afx\";\n    }\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "DialogTitleCapitalization"
  },
  "hash": "fdeeb8baef401bad15a5bc70961a9c3298bd71af7287c7558f75e38a683952d5"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "'equals()' between objects of inconvertible types",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "No class found which is a subtype of both 'PsiDirectory' and 'VirtualFile'",
  "detailsInfo": "Reports calls to `equals()` where the target and argument are of incompatible types.\n\nWhile such a call might theoretically be useful, most likely it is a bug.\n\n**Example:**\n\n\n      new HashSet<String>().equals(new TreeSet<Integer>());\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/util/ComposerUtil.java",
      "language": "JAVA",
      "line": 43,
      "offset": 88,
      "length": 6,
      "code": {
        "startLine": 41,
        "length": 6,
        "offset": 234,
        "surroundingCode": "            composerFile = getComposerManifestInDirectory(currentDirectory);\n            currentDirectory = currentDirectory.getParentDirectory();\n        } while (composerFile == null && currentDirectory != null && !currentDirectory.equals(guessProjectDir(currentDirectory.getProject())));\n\n        return composerFile;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "EqualsBetweenInconvertibleTypes"
  },
  "hash": "6cc45c518ec1255a55d9cd847eede013a15040a59f01aae9b0655c0ccde42ebe"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "'equals()' between objects of inconvertible types",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "No class found which is a subtype of both 'PsiDirectory' and 'VirtualFile'",
  "detailsInfo": "Reports calls to `equals()` where the target and argument are of incompatible types.\n\nWhile such a call might theoretically be useful, most likely it is a bug.\n\n**Example:**\n\n\n      new HashSet<String>().equals(new TreeSet<Integer>());\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/util/NeosUtil.java",
      "language": "JAVA",
      "line": 86,
      "offset": 38,
      "length": 6,
      "code": {
        "startLine": 84,
        "length": 6,
        "offset": 163,
        "surroundingCode": "                && !currentDirectory.getName().equals(\"Fusion\")\n                && !currentDirectory.equals(packageDirectory)\n                && !currentDirectory.equals(guessProjectDir(currentDirectory.getProject())));\n\n        if (!fusionDirectoryExists) {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "EqualsBetweenInconvertibleTypes"
  },
  "hash": "934484526d57fe702004549a6d1c9bc8ddd0e1365e51101679d8d454019d031f"
},{
  "tool": "Code Inspection",
  "category": "Code style issues",
  "type": "Field may be 'final'",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Field `insertHandler` may be 'final'",
  "detailsInfo": "Reports fields that can be safely made `final`. All `final` fields have a value and this value does not change, which can make the code easier to reason about.\n\nTo avoid too expensive analysis, this inspection only reports if the field has a `private` modifier\nor it is defined in a local or anonymous class.\nA field can be `final` if:\n\n* It is `static` and initialized once in its declaration or in one `static` initializer.\n* It is non-`static` and initialized once in its declaration, in one instance initializer or in every constructor\n\nAnd it is not modified anywhere else.\n\n**Example:**\n\n\n      public class Person {\n        private String name; // can be final\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Person {\n        private final String name;\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n      }\n\n\nUse the \"Annotations\" button to modify the list of annotations that assume implicit field write.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/config/nodeTypes/NodeTypesConfigLookup.java",
      "language": "JAVA",
      "line": 29,
      "offset": 42,
      "length": 13,
      "code": {
        "startLine": 27,
        "length": 13,
        "offset": 67,
        "surroundingCode": "\n    private String name;\n    private InsertHandler<LookupElement> insertHandler = null;\n\n    public NodeTypesConfigLookup(String name) {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "FieldMayBeFinal"
  },
  "hash": "351e9bbab5fc9d294d62e136181393f337a2d7d984227ca2130591e75f8e2a20"
},{
  "tool": "Code Inspection",
  "category": "Code style issues",
  "type": "Field may be 'final'",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Field `name` may be 'final'",
  "detailsInfo": "Reports fields that can be safely made `final`. All `final` fields have a value and this value does not change, which can make the code easier to reason about.\n\nTo avoid too expensive analysis, this inspection only reports if the field has a `private` modifier\nor it is defined in a local or anonymous class.\nA field can be `final` if:\n\n* It is `static` and initialized once in its declaration or in one `static` initializer.\n* It is non-`static` and initialized once in its declaration, in one instance initializer or in every constructor\n\nAnd it is not modified anywhere else.\n\n**Example:**\n\n\n      public class Person {\n        private String name; // can be final\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Person {\n        private final String name;\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n      }\n\n\nUse the \"Annotations\" button to modify the list of annotations that assume implicit field write.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/config/nodeTypes/NodeTypesConfigLookup.java",
      "language": "JAVA",
      "line": 28,
      "offset": 20,
      "length": 4,
      "code": {
        "startLine": 26,
        "length": 4,
        "offset": 78,
        "surroundingCode": "public class NodeTypesConfigLookup extends LookupElement{\n\n    private String name;\n    private InsertHandler<LookupElement> insertHandler = null;\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "FieldMayBeFinal"
  },
  "hash": "c52691f4d0393e4ea79b00f5939b2ce9772c9f0a7d37e57432ed88e22c8121de"
},{
  "tool": "Code Inspection",
  "category": "Memory",
  "type": "Inner class may be 'static'",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Inner class `PairsByTransId` may be 'static'",
  "detailsInfo": "Reports inner classes that can be made `static`.\n\nA `static` inner class does not keep an implicit reference to its enclosing instance.\nWhen using Java 17 or before,\nthis prevents a common cause of memory leaks and uses less memory per instance of the class.\n\n**Example:**\n\n\n      public class Outer {\n        class Inner { // not static\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Outer {\n        static class Inner {\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/actions/TranslateNodeTypeAction.java",
      "language": "JAVA",
      "line": 230,
      "offset": 11,
      "length": 14,
      "code": {
        "startLine": 228,
        "length": 14,
        "offset": 17,
        "surroundingCode": "    }\n\n    class PairsByTransId extends LinkedHashMap<String,YAMLKeyValue> {}\n\n    private LinkedHashMap<String, PairsByTransId> extractNodeTypeTranslationIds(List<YAMLKeyValue> pairs) {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "InnerClassMayBeStatic"
  },
  "hash": "5c809ffa1658103da9f668a89ca233595aeba97bc9e99805ee1addb4e27bb9e5"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Usage of API marked for removal",
  "tags": [
    "JAVA"
  ],
  "severity": "Critical",
  "comment": "'addBrowseFolderListener(java.lang.@org.jetbrains.annotations.Nullable String, java.lang.@org.jetbrains.annotations.Nullable String, com.intellij.openapi.project.@org.jetbrains.annotations.Nullable Project, com.intellij.openapi.fileChooser.FileChooserDescriptor, com.intellij.openapi.ui.TextComponentAccessor)' is deprecated and marked for removal",
  "detailsInfo": "Reports usages of deprecated APIs (classes, fields, and methods) that are marked for removal with `@Deprecated(`**forRemoval**`=true)`.\n\n\nThe code that uses an API marked for removal may cause a runtime error with a future version of the API. That is why\nthe recommended severity for this inspection is *Error*.\n\n\nYou can change the severity to *Warning* if you want to use the same code highlighting as in ordinary deprecation.\n\nNew in 2017.3",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/refactoring/MovePrototypeDialog.java",
      "language": "JAVA",
      "line": 279,
      "offset": 15,
      "length": 23,
      "code": {
        "startLine": 277,
        "length": 23,
        "offset": 92,
        "surroundingCode": "                .withTreeRootVisible(true)\n                .withTitle(title);\n        field.addBrowseFolderListener(title, null, myProject, descriptor, TextComponentAccessors.TEXT_FIELD_WITH_HISTORY_WHOLE_TEXT);\n        String initialPath = myContextFile.getPresentableUrl();\n        String suggestedTargetFileName = getSuggestedTargetFileName(initialPath, mySelectedPrototypes);"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "MarkedForRemoval"
  },
  "hash": "47f26c3b24525a3d32ec5e890408fc432e0b9a8ad5e5f8e6fcc0a9e805346b88"
},{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Usage of API marked for removal",
  "tags": [
    "JAVA"
  ],
  "severity": "Critical",
  "comment": "'com.intellij.diagnostic.IdeaReportingEvent' is deprecated and marked for removal",
  "detailsInfo": "Reports usages of deprecated APIs (classes, fields, and methods) that are marked for removal with `@Deprecated(`**forRemoval**`=true)`.\n\n\nThe code that uses an API marked for removal may cause a runtime error with a future version of the API. That is why\nthe recommended severity for this inspection is *Error*.\n\n\nYou can change the severity to *Warning* if you want to use the same code highlighting as in ordinary deprecation.\n\nNew in 2017.3",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/errorReporting/SentryErrorReporter.java",
      "language": "JAVA",
      "line": 45,
      "offset": 38,
      "length": 18,
      "code": {
        "startLine": 43,
        "length": 18,
        "offset": 145,
        "surroundingCode": "        ArrayList<String> eventIds = new ArrayList<>();\n        for (IdeaLoggingEvent ideaEvent : events) {\n            if (ideaEvent instanceof IdeaReportingEvent && ideaEvent.getData() instanceof AbstractMessage) {\n                Throwable ex = ((AbstractMessage) ideaEvent.getData()).getThrowable();\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "MarkedForRemoval"
  },
  "hash": "4f2c4e7f2a388c05ecb8ab168c550a287c4d04a64695026983e4f0bdaeaf2bf8"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated parameter overrides @NotNull parameter",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/afx/AfxSyntaxHighlighter.java",
      "language": "JAVA",
      "line": 36,
      "offset": 74,
      "length": 9,
      "code": {
        "startLine": 34,
        "length": 9,
        "offset": 88,
        "surroundingCode": "\n    @Override\n    public TextAttributesKey @NotNull [] getTokenHighlights(IElementType tokenType) {\n        if (ourMap1.containsKey(tokenType)) {\n            return pack(ourMap1.get(tokenType));"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "1f6f1f0002f8dea0f906038ed674431786a001cc4bcc9a97c5c8944d03f695b7"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated parameter overrides @NotNull parameter",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/formatter/FusionCodeStyleSettingsProvider.java",
      "language": "JAVA",
      "line": 43,
      "offset": 76,
      "length": 17,
      "code": {
        "startLine": 41,
        "length": 17,
        "offset": 188,
        "surroundingCode": "        return new CodeStyleAbstractConfigurable(settings, modelSettings, \"Neos Fusion\") {\n            @Override\n            protected CodeStyleAbstractPanel createPanel(CodeStyleSettings codeStyleSettings) {\n                return new FusionCodeStyleMainPanel(getCurrentSettings(), codeStyleSettings);\n            }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "1f8bdbcf6d21a1530fe0ec6072ae1750454773a4c94c0ea067e6b2c26669b87d"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated method overrides method annotated with @NotNull",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/resolve/ref/FusionStringReference.java",
      "language": "JAVA",
      "line": 68,
      "offset": 22,
      "length": 17,
      "code": {
        "startLine": 66,
        "length": 17,
        "offset": 36,
        "surroundingCode": "\n    @Override\n    public TextRange getRangeInElement() {\n        FusionValueStringLineContent content = getElement().getValueStringLineContent();\n        if (content != null) {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "2647abae0e7f37b80cede0237125464eab06f5f02bf4352a20f0cfb34525452e"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated method overrides method annotated with @NotNull",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/eel/formatter/EelCodeStyleSettingsProvider.java",
      "language": "JAVA",
      "line": 43,
      "offset": 46,
      "length": 11,
      "code": {
        "startLine": 41,
        "length": 11,
        "offset": 155,
        "surroundingCode": "        return new CodeStyleAbstractConfigurable(settings, modelSettings, \"Neos EEL\") {\n            @Override\n            protected CodeStyleAbstractPanel createPanel(CodeStyleSettings codeStyleSettings) {\n                return new EelCodeStyleMainPanel(getCurrentSettings(), codeStyleSettings);\n            }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "29b16301c0e384ca051b5707119f88aa3dcd89d175fe47737f71e16e9f9a9a96"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated parameter overrides @NotNull parameter",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/actions/CreateNodeTypeDefinition.java",
      "language": "JAVA",
      "line": 58,
      "offset": 40,
      "length": 7,
      "code": {
        "startLine": 56,
        "length": 7,
        "offset": 54,
        "surroundingCode": "\n    @Override\n    protected void buildDialog(Project project, PsiDirectory directory, CreateFileFromTemplateDialog.Builder builder) {\n        builder.setTitle(NEW_NODE_TYPE_DEFINITION).addKind(\"Empty File\", NeosIcons.NODE_TYPE, NODE_TYPE_TEMPLATE_NAME);\n        builder.setTitle(NEW_NODE_TYPE_DEFINITION).addKind(\"Document\", NeosIcons.NODE_TYPE, DOCUMENT_NODE_TYPE_TEMPLATE_NAME);"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "3ae5b63f374a307e68e196c3a88ecf47a91621a2c6fbbcc8c8df5d0231d0f248"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated parameter overrides @NotNull parameter",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/afx/parser/AfxParserDefinition.java",
      "language": "JAVA",
      "line": 55,
      "offset": 54,
      "length": 4,
      "code": {
        "startLine": 53,
        "length": 4,
        "offset": 68,
        "surroundingCode": "\n    @Override\n    public @NotNull PsiElement createElement(ASTNode node) {\n        return super.createElement(node);\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "404e12e2eca71c1c46500a0cda92a7c70bdb18fdad2ccdccd11aa9fa406d5ddd"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated method overrides method annotated with @NotNull",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/pages/FusionColorSettingsPage.java",
      "language": "JAVA",
      "line": 127,
      "offset": 30,
      "length": 19,
      "code": {
        "startLine": 125,
        "length": 19,
        "offset": 56,
        "surroundingCode": "    @NotNull\n    @Override\n    public ColorDescriptor[] getColorDescriptors() {\n        return new ColorDescriptor[0];\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "44269e892092154a4f14a0893515f259b9d0127878188eaff23d695f481e638e"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated method overrides method annotated with @NotNull",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/FusionParserDefinition.java",
      "language": "JAVA",
      "line": 88,
      "offset": 30,
      "length": 31,
      "code": {
        "startLine": 86,
        "length": 31,
        "offset": 44,
        "surroundingCode": "\n    @Override\n    public SpaceRequirements spaceExistenceTypeBetweenTokens(ASTNode left, ASTNode right) {\n        return SpaceRequirements.MAY;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "4c92586cf9e3d64da2d32dc62f5066d265f8cee7ce37c0199a37209cd1781451"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated method overrides method annotated with @NotNull",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/resolve/ref/FusionResourceStringReference.java",
      "language": "JAVA",
      "line": 51,
      "offset": 22,
      "length": 17,
      "code": {
        "startLine": 49,
        "length": 17,
        "offset": 36,
        "surroundingCode": "\n    @Override\n    public TextRange getRangeInElement() {\n        FusionValueStringLineContent content = getElement().getValueStringLineContent();\n        if (content != null) {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "4d87a188958cc35b4718ffcd924b47b84c90e056f847a20c25a4a54ac47193fe"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated method overrides method annotated with @NotNull",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/yaml/references/value/ValueReferenceContributor.java",
      "language": "JAVA",
      "line": 44,
      "offset": 31,
      "length": 22,
      "code": {
        "startLine": 42,
        "length": 22,
        "offset": 65,
        "surroundingCode": "        @NotNull\n        @Override\n        public PsiReference[] getReferencesByElement(@NotNull PsiElement element, @NotNull ProcessingContext context) {\n            if(!NeosProjectService.isEnabled(element)) {\n                return new PsiReference[0];"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "61204cbbf7b2504c541955daaffe9450ac4487be51f537ca059ebcefd269061a"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated parameter overrides @NotNull parameter",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/afx/parser/AfxParserDefinition.java",
      "language": "JAVA",
      "line": 50,
      "offset": 48,
      "length": 12,
      "code": {
        "startLine": 48,
        "length": 12,
        "offset": 62,
        "surroundingCode": "\n    @Override\n    public PsiFile createFile(FileViewProvider viewProvider) {\n        return new AfxFile(viewProvider);\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "61af4d85b68bde45ae17fb3826532aee0a89aad88bc2a1f0e671100fece36b28"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated method overrides method annotated with @NotNull",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/yaml/references/value/ValueReference.java",
      "language": "JAVA",
      "line": 43,
      "offset": 28,
      "length": 12,
      "code": {
        "startLine": 41,
        "length": 12,
        "offset": 54,
        "surroundingCode": "    @NotNull\n    @Override\n    public ResolveResult[] multiResolve(boolean incompleteCode) {\n        String value;\n        value = yamlElement.getText().replaceAll(\"^\\\"|\\\"$\", \"\");"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "634d60066d79d8144bbdaf9df6716834a202d65498275243b3554a0c2ad53c7c"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated method overrides method annotated with @NotNull",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/formatter/FusionCodeStyleSettingsProvider.java",
      "language": "JAVA",
      "line": 43,
      "offset": 46,
      "length": 11,
      "code": {
        "startLine": 41,
        "length": 11,
        "offset": 158,
        "surroundingCode": "        return new CodeStyleAbstractConfigurable(settings, modelSettings, \"Neos Fusion\") {\n            @Override\n            protected CodeStyleAbstractPanel createPanel(CodeStyleSettings codeStyleSettings) {\n                return new FusionCodeStyleMainPanel(getCurrentSettings(), codeStyleSettings);\n            }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "721371a61eb4828194380a5d3e27dd538de89237acc6303596b9c1ab01a453ad"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated method overrides method annotated with @NotNull",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/yaml/references/nodeType/NodeTypeReference.java",
      "language": "JAVA",
      "line": 83,
      "offset": 28,
      "length": 12,
      "code": {
        "startLine": 81,
        "length": 12,
        "offset": 54,
        "surroundingCode": "    @NotNull\n    @Override\n    public ResolveResult[] multiResolve(boolean incompleteCode) {\n\n        // files which contain the NodeType definition"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "7772eb8c0c2eb3e1da2d60a2ff4555cb1b28c9fcfa3aee38662951046119d95c"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated method overrides method annotated with @NotNull",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/eel/EelParserDefinition.java",
      "language": "JAVA",
      "line": 49,
      "offset": 22,
      "length": 12,
      "code": {
        "startLine": 47,
        "length": 12,
        "offset": 36,
        "surroundingCode": "\n    @Override\n    public PsiParser createParser(Project project) {\n        return new EelParser();\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "803cf366ae6035e5ebb0ba23f059b8a9131e09a05590e591aba422cbae851f07"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated method overrides method annotated with @NotNull",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/yaml/references/nodeType/NodeTypeReferenceContributor.java",
      "language": "JAVA",
      "line": 107,
      "offset": 31,
      "length": 22,
      "code": {
        "startLine": 105,
        "length": 22,
        "offset": 65,
        "surroundingCode": "        @NotNull\n        @Override\n        public PsiReference[] getReferencesByElement(@NotNull PsiElement element, @NotNull ProcessingContext context) {\n            YAMLSequenceItem yamlItem = getParent((YAMLPsiElement) element, YAMLSequenceItem.class);\n            YAMLKeyValue yamlElement = getParentKey(yamlItem);"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "82298a7ab5f10b128046bc1d3ff8c0e67e8412ccc6c300254da276733ceb8e00"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated parameter overrides @NotNull parameter",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/actions/CreateFusionFile.java",
      "language": "JAVA",
      "line": 21,
      "offset": 40,
      "length": 7,
      "code": {
        "startLine": 19,
        "length": 7,
        "offset": 54,
        "surroundingCode": "\n    @Override\n    protected void buildDialog(Project project, PsiDirectory directory, CreateFileFromTemplateDialog.Builder builder) {\n        builder.setTitle(NEW_FUSION_FILE).addKind(\"Empty File\", FusionIcons.FILE, \"Fusion File\");\n        builder.setTitle(NEW_FUSION_FILE).addKind(\"Content Prototype\", FusionIcons.PROTOTYPE, \"Fusion Content Prototype\");"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "85eb19acd8c327de1a80afdc11d57241702c58fc7f2aa8e9326fd7a5e68f8237"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated parameter overrides @NotNull parameter",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/actions/CreateNodeTypeDefinition.java",
      "language": "JAVA",
      "line": 58,
      "offset": 62,
      "length": 9,
      "code": {
        "startLine": 56,
        "length": 9,
        "offset": 76,
        "surroundingCode": "\n    @Override\n    protected void buildDialog(Project project, PsiDirectory directory, CreateFileFromTemplateDialog.Builder builder) {\n        builder.setTitle(NEW_NODE_TYPE_DEFINITION).addKind(\"Empty File\", NeosIcons.NODE_TYPE, NODE_TYPE_TEMPLATE_NAME);\n        builder.setTitle(NEW_NODE_TYPE_DEFINITION).addKind(\"Document\", NeosIcons.NODE_TYPE, DOCUMENT_NODE_TYPE_TEMPLATE_NAME);"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "86549113ffae33e27ff729e4277760ff44e10fb5d2931d082533dcec1c4c50a2"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated parameter overrides @NotNull parameter",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/actions/CreateFusionFile.java",
      "language": "JAVA",
      "line": 21,
      "offset": 62,
      "length": 9,
      "code": {
        "startLine": 19,
        "length": 9,
        "offset": 76,
        "surroundingCode": "\n    @Override\n    protected void buildDialog(Project project, PsiDirectory directory, CreateFileFromTemplateDialog.Builder builder) {\n        builder.setTitle(NEW_FUSION_FILE).addKind(\"Empty File\", FusionIcons.FILE, \"Fusion File\");\n        builder.setTitle(NEW_FUSION_FILE).addKind(\"Content Prototype\", FusionIcons.PROTOTYPE, \"Fusion Content Prototype\");"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "8884c667367c5530a997c3639043d79d56bb6cbeef64dabc22d2605e865be00a"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated method overrides method annotated with @NotNull",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/eel/EelParserDefinition.java",
      "language": "JAVA",
      "line": 54,
      "offset": 29,
      "length": 15,
      "code": {
        "startLine": 52,
        "length": 15,
        "offset": 43,
        "surroundingCode": "\n    @Override\n    public IFileElementType getFileNodeType() {\n        return EelFileStub.TYPE;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "8af1bd9040fe9b8ba69c03eef435918b4f4c7893d7b168367c68df492a8507d1"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated parameter overrides @NotNull parameter",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/actions/CreateXliffFile.java",
      "language": "JAVA",
      "line": 23,
      "offset": 62,
      "length": 9,
      "code": {
        "startLine": 21,
        "length": 9,
        "offset": 76,
        "surroundingCode": "\n    @Override\n    protected void buildDialog(Project project, PsiDirectory directory, CreateFileFromTemplateDialog.Builder builder) {\n        builder.setTitle(NEW_XLIFF_FILE).addKind(\"Empty File\", XliffIcons.XLIFF_FILE, \"XLIFF File\");\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "8ee4b06e863789609f04bf89ab20a21b2340301bd806add18986783ffc4f510a"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated parameter overrides @NotNull parameter",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/completion/MetaPathProvider.java",
      "language": "JAVA",
      "line": 31,
      "offset": 95,
      "length": 7,
      "code": {
        "startLine": 29,
        "length": 7,
        "offset": 109,
        "surroundingCode": "\n    @Override\n    protected void addCompletions(@NotNull CompletionParameters parameters, ProcessingContext context, @NotNull CompletionResultSet result) {\n        result.addElement(LookupElementBuilder.create(\"process\"));\n        result.addElement(LookupElementBuilder.create(\"context\"));"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "928b123848a4826e860ab33620fec56fb9df05a4cf8ebcab9528d04eeedf28d1"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated method overrides method annotated with @NotNull",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/eel/EelParserDefinition.java",
      "language": "JAVA",
      "line": 88,
      "offset": 30,
      "length": 31,
      "code": {
        "startLine": 86,
        "length": 31,
        "offset": 44,
        "surroundingCode": "\n    @Override\n    public SpaceRequirements spaceExistenceTypeBetweenTokens(ASTNode left, ASTNode right) {\n        return SpaceRequirements.MAY;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "99ef2436212dd556af0710a3383b3957ef6ec6c21c50f288ffb689c0313c4210"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated parameter overrides @NotNull parameter",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/completion/PrototypeProvider.java",
      "language": "JAVA",
      "line": 39,
      "offset": 95,
      "length": 7,
      "code": {
        "startLine": 37,
        "length": 7,
        "offset": 109,
        "surroundingCode": "\n    @Override\n    protected void addCompletions(@NotNull CompletionParameters parameters, ProcessingContext context, @NotNull CompletionResultSet result) {\n        Collection<String> keys = StubIndex.getInstance().getAllKeys(FusionPrototypeDeclarationIndex.KEY, parameters.getPosition().getProject());\n        Project project = parameters.getPosition().getProject();"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "9ff3e1999a85e955247921647445d930f2092a6240f8c45fd4e9d6ca1570192a"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated parameter overrides @NotNull parameter",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/eel/formatter/EelCodeStyleSettingsProvider.java",
      "language": "JAVA",
      "line": 34,
      "offset": 75,
      "length": 8,
      "code": {
        "startLine": 32,
        "length": 8,
        "offset": 102,
        "surroundingCode": "    @Nullable\n    @Override\n    public CustomCodeStyleSettings createCustomSettings(CodeStyleSettings settings) {\n        return new EelCodeStyleSettings(settings);\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "aa0c028c588592563c9e775fc2e82ad04203a961828f6dad576cee2bb2b85a74"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated method overrides method annotated with @NotNull",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/editor/FusionBraceMatcher.java",
      "language": "JAVA",
      "line": 47,
      "offset": 24,
      "length": 8,
      "code": {
        "startLine": 45,
        "length": 8,
        "offset": 45,
        "surroundingCode": "     */\n    @Override\n    public BracePair[] getPairs() {\n        return PAIRS;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "aa7e0151e5dca95c3a781d003d6db3df1fc9aa3e2e094a4de5ab94e802abdfab"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated parameter overrides @NotNull parameter",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/actions/CreateXliffFile.java",
      "language": "JAVA",
      "line": 23,
      "offset": 40,
      "length": 7,
      "code": {
        "startLine": 21,
        "length": 7,
        "offset": 54,
        "surroundingCode": "\n    @Override\n    protected void buildDialog(Project project, PsiDirectory directory, CreateFileFromTemplateDialog.Builder builder) {\n        builder.setTitle(NEW_XLIFF_FILE).addKind(\"Empty File\", XliffIcons.XLIFF_FILE, \"XLIFF File\");\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "b205c92201873b9a88fb2c1e95dd70f7b83d7fcd03a841a2aa80462e37a2ef36"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated parameter overrides @NotNull parameter",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/eel/formatter/EelCodeStyleSettingsProvider.java",
      "language": "JAVA",
      "line": 43,
      "offset": 76,
      "length": 17,
      "code": {
        "startLine": 41,
        "length": 17,
        "offset": 185,
        "surroundingCode": "        return new CodeStyleAbstractConfigurable(settings, modelSettings, \"Neos EEL\") {\n            @Override\n            protected CodeStyleAbstractPanel createPanel(CodeStyleSettings codeStyleSettings) {\n                return new EelCodeStyleMainPanel(getCurrentSettings(), codeStyleSettings);\n            }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "b6a3ee3742a22a1c351b7a780c02e48619482d9e6cf9157a6f1f51c9b71dbe88"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated parameter overrides @NotNull parameter",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/FusionParserDefinition.java",
      "language": "JAVA",
      "line": 83,
      "offset": 48,
      "length": 16,
      "code": {
        "startLine": 81,
        "length": 16,
        "offset": 62,
        "surroundingCode": "\n    @Override\n    public PsiFile createFile(FileViewProvider fileViewProvider) {\n        return new FusionFile(fileViewProvider);\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "b8c3913440f69305aee2246af1d693854d6f5d758175bc530132bd766e4c4231"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated method overrides method annotated with @NotNull",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/afx/parser/AfxParserDefinition.java",
      "language": "JAVA",
      "line": 50,
      "offset": 20,
      "length": 10,
      "code": {
        "startLine": 48,
        "length": 10,
        "offset": 34,
        "surroundingCode": "\n    @Override\n    public PsiFile createFile(FileViewProvider viewProvider) {\n        return new AfxFile(viewProvider);\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "ba6456b8eea3904163f9a5b2c2f769305baabcf00b03548d137ecd028b49b3d9"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated parameter overrides @NotNull parameter",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/formatter/FusionCodeStyleSettingsProvider.java",
      "language": "JAVA",
      "line": 34,
      "offset": 75,
      "length": 8,
      "code": {
        "startLine": 32,
        "length": 8,
        "offset": 102,
        "surroundingCode": "    @Nullable\n    @Override\n    public CustomCodeStyleSettings createCustomSettings(CodeStyleSettings settings) {\n        return new FusionCodeStyleSettings(settings);\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "bada33632e8206ea2308d83d8d8cdc5be7f1ae0897b56ba12990e2c5747a8700"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated method overrides method annotated with @NotNull",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/yaml/references/nodeType/NodeTypeReference.java",
      "language": "JAVA",
      "line": 77,
      "offset": 21,
      "length": 11,
      "code": {
        "startLine": 75,
        "length": 11,
        "offset": 47,
        "surroundingCode": "    @NotNull\n    @Override\n    public Object[] getVariants() {\n        return new Object[0];\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "be4a78886fffdfb3e8b2dfdafbed298ffa3a666251c3c403b19ce11fba96f5f3"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated method overrides method annotated with @NotNull",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/afx/parser/AfxParserDefinition.java",
      "language": "JAVA",
      "line": 45,
      "offset": 29,
      "length": 15,
      "code": {
        "startLine": 43,
        "length": 15,
        "offset": 43,
        "surroundingCode": "\n    @Override\n    public IFileElementType getFileNodeType() {\n        return FILE;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "c6363dfaf53040ccd763df25f39bf4288b4770919558d417d182779299fc4053"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated method overrides method annotated with @NotNull",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/pages/FusionColorSettingsPage.java",
      "language": "JAVA",
      "line": 121,
      "offset": 35,
      "length": 23,
      "code": {
        "startLine": 119,
        "length": 23,
        "offset": 61,
        "surroundingCode": "    @NotNull\n    @Override\n    public AttributesDescriptor[] getAttributeDescriptors() {\n        return DESCRIPTORS;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "c7a3733b48d2dd1d0c11d4e0837d9eefe91cbd73cc53e5574527e1247f562a16"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated parameter overrides @NotNull parameter",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/usages/UsagesTypeProvider.java",
      "language": "JAVA",
      "line": 39,
      "offset": 56,
      "length": 7,
      "code": {
        "startLine": 37,
        "length": 7,
        "offset": 70,
        "surroundingCode": "\n    @Override\n    public @Nullable UsageType getUsageType(PsiElement element) {\n\n        if (element instanceof FusionType) {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "d10f8d96e0e5174ac9e637fd142458c23ea5d89808ef9192292522b363d42cb0"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated parameter overrides @NotNull parameter",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/eel/EelParserDefinition.java",
      "language": "JAVA",
      "line": 83,
      "offset": 48,
      "length": 16,
      "code": {
        "startLine": 81,
        "length": 16,
        "offset": 62,
        "surroundingCode": "\n    @Override\n    public PsiFile createFile(FileViewProvider fileViewProvider) {\n        return new EelFile(fileViewProvider);\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "d1a75625a578111f10ab1e377a7931339b6acf35fa8c77aef85a6ca838adf4f7"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated method overrides method annotated with @NotNull",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/yaml/references/value/ValueReference.java",
      "language": "JAVA",
      "line": 73,
      "offset": 21,
      "length": 11,
      "code": {
        "startLine": 71,
        "length": 11,
        "offset": 47,
        "surroundingCode": "    @NotNull\n    @Override\n    public Object[] getVariants() {\n        return new Object[0];\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "d41c76fd9ac3541c9414fd3ec874adeeb49a65bf4ebb44c2604de9b343819d62"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated parameter overrides @NotNull parameter",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/structure/FusionStructureViewBuilderFactory.java",
      "language": "JAVA",
      "line": 35,
      "offset": 71,
      "length": 7,
      "code": {
        "startLine": 33,
        "length": 7,
        "offset": 98,
        "surroundingCode": "    @Nullable\n    @Override\n    public StructureViewBuilder getStructureViewBuilder(final PsiFile psiFile) {\n        final FusionFile fusionFile = (FusionFile) psiFile;\n        return new TreeBasedStructureViewBuilder() {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "dac881a40c3131e5bef9154e8a6ce16e53cbcacba0ef31da8e3347147bafe3c1"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated method overrides method annotated with @NotNull",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/FusionParserDefinition.java",
      "language": "JAVA",
      "line": 49,
      "offset": 22,
      "length": 12,
      "code": {
        "startLine": 47,
        "length": 12,
        "offset": 36,
        "surroundingCode": "\n    @Override\n    public PsiParser createParser(Project project) {\n        return new FusionParser();\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "e22a96a616ab07a09c55496ac9673d394c401a6391e29e201b6470eb60f422f3"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated method overrides method annotated with @NotNull",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/injection/FusionLanguageInjectionSupport.java",
      "language": "JAVA",
      "line": 36,
      "offset": 20,
      "length": 17,
      "code": {
        "startLine": 34,
        "length": 17,
        "offset": 46,
        "surroundingCode": "    @NotNull\n    @Override\n    public Class[] getPatternClasses() {\n        return new Class[]{FusionPatterns.class};\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "e6ba63127b7fd38e7064d3be56169449929877fcd2e5a6f4a2d32f9c4b037319"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated method overrides method annotated with @NotNull",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/FusionParserDefinition.java",
      "language": "JAVA",
      "line": 83,
      "offset": 20,
      "length": 10,
      "code": {
        "startLine": 81,
        "length": 10,
        "offset": 34,
        "surroundingCode": "\n    @Override\n    public PsiFile createFile(FileViewProvider fileViewProvider) {\n        return new FusionFile(fileViewProvider);\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "ee1191e100292aaa26e2464f75dbc76c31c2a661d51d239375673e0523d2799f"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated method overrides method annotated with @NotNull",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/eel/EelParserDefinition.java",
      "language": "JAVA",
      "line": 83,
      "offset": 20,
      "length": 10,
      "code": {
        "startLine": 81,
        "length": 10,
        "offset": 34,
        "surroundingCode": "\n    @Override\n    public PsiFile createFile(FileViewProvider fileViewProvider) {\n        return new EelFile(fileViewProvider);\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "f53d58317197e6e2f17548a90198726d8363528ad1502231be4f2719061fab0e"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated method overrides method annotated with @NotNull",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/FusionParserDefinition.java",
      "language": "JAVA",
      "line": 54,
      "offset": 29,
      "length": 15,
      "code": {
        "startLine": 52,
        "length": 15,
        "offset": 43,
        "surroundingCode": "\n    @Override\n    public IFileElementType getFileNodeType() {\n        return FusionFileStub.TYPE;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "fd67d4ca42375843a432e3392e77ce6a558ecda62c8d8d341e9b7e2ba5ed5cf9"
},{
  "tool": "Code Inspection",
  "category": "Nullability problems",
  "type": "@NotNull/@Nullable problems",
  "tags": [
    "JAVA",
    "CWE Top 25"
  ],
  "severity": "High",
  "comment": "Not annotated method overrides method annotated with @NotNull",
  "detailsInfo": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/yaml/references/nodeType/NodeTypeReferenceContributor.java",
      "language": "JAVA",
      "line": 74,
      "offset": 31,
      "length": 22,
      "code": {
        "startLine": 72,
        "length": 22,
        "offset": 65,
        "surroundingCode": "        @NotNull\n        @Override\n        public PsiReference[] getReferencesByElement(@NotNull PsiElement element, @NotNull ProcessingContext context) {\n            YAMLKeyValue yamlElement = (YAMLKeyValue) element;\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "NullableProblems"
  },
  "hash": "fdefdd42ef11b91f6fcbf81e6511b5ec6f1ca9b930de37b663ef779dd8ae5066"
},{
  "tool": "Code Inspection",
  "category": "Control flow issues",
  "type": "Unnecessary 'null' check before method call",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unnecessary 'null' check before 'isInstance()' call",
  "detailsInfo": "Reports `null` checks followed by a method call that will definitely return `false` when `null` is passed (e.g. `Class.isInstance`).\n\nSuch a check seems excessive as the method call will always return `false` in this case.\n\n**Example:**\n\n\n      if (x != null && myClass.isInstance(x)) { ... }\n\nAfter the quick-fix is applied:\n\n\n      if (myClass.isInstance(x)) { ... }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/util/psi/ParentPathPatternCondition.java",
      "language": "JAVA",
      "line": 23,
      "offset": 16,
      "length": 18,
      "code": {
        "startLine": 21,
        "length": 18,
        "offset": 125,
        "surroundingCode": "        for (Class<? extends PsiElement> aClass : classes) {\n            psiElement = psiElement.getParent();\n            if(psiElement == null || !aClass.isInstance(psiElement)) {\n                return false;\n            }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "PointlessNullCheck"
  },
  "hash": "6b73d35e0171f34a681ac776a472c3b76bf4d0c4447adeea4d4ea790b87dc545"
},{
  "tool": "Code Inspection",
  "category": "Declaration redundancy",
  "type": "'protected' member in 'final' class",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Class member declared `protected` in 'final' class",
  "detailsInfo": "Reports `protected` members in `final`classes.\n\nSince `final` classes cannot be inherited, marking the method as `protected`\nmay be confusing. It is better to declare such members as `private` or package-visible instead.\n\n**Example:**\n\n    record Bar(int a, int b) {\n      protected int sum() { \n         return a + b;\n      }\n    }\n\nAfter the quick-fix is applied:\n\n    record Bar(int a, int b) {\n      int sum() { \n         return a + b;\n      }\n    }\n\nAs shown in the example, a class can be marked as `final` explicitly or implicitly.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/xliff/XliffBundle.java",
      "language": "JAVA",
      "line": 15,
      "offset": 5,
      "length": 9,
      "code": {
        "startLine": 13,
        "length": 9,
        "offset": 6,
        "surroundingCode": "\n\n    protected XliffBundle() {\n        super(BUNDLE);\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "ProtectedMemberInFinalClass"
  },
  "hash": "13c6e08b570bdc7167fc33dbf14a4dd82c5c7eadba02b3e76229b2ace347b9e8"
},{
  "tool": "Code Inspection",
  "category": "Verbose or redundant code constructs",
  "type": "Redundant 'isInstance()' or 'cast()' call",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Redundant call to `isInstance()`",
  "detailsInfo": "Reports redundant calls of `java.lang.Class` methods.\n\nFor example, `Xyz.class.isInstance(object)` can be replaced with `object instanceof Xyz`.\nThe instanceof check is preferred: even though the performance will probably be the same as these methods are intrinsics,\nthey better indicate a static check.\n\nNew in 2018.2",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/util/psi/ParentKeysPatternCondition.java",
      "language": "JAVA",
      "line": 58,
      "offset": 40,
      "length": 10,
      "code": {
        "startLine": 56,
        "length": 10,
        "offset": 130,
        "surroundingCode": "        while (currentElement != null) {\n            if (i < Array.getLength(this.keys)) {\n                if (YAMLKeyValue.class.isInstance(currentElement)) {\n                    expectedKey = this.keys[i++];\n                    if (!expectedKey.equals(\"*\") && !expectedKey.equals(((YAMLKeyValue) currentElement).getKeyText())) {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "RedundantClassCall"
  },
  "hash": "79d10a970e7da54ab834e9214edd3a490ba1d87d794029790c8e1758a35537f5"
},{
  "tool": "Code Inspection",
  "category": "RegExp",
  "type": "Regular expression can be simplified",
  "tags": [
    "RegExp"
  ],
  "severity": "Moderate",
  "comment": "`[^\\s]` can be simplified to '\\\\S'",
  "detailsInfo": "Reports regular expressions that can be simplified.\n\n**Example:**\n\n\n      [a] xx* [ah-hz]\n\nAfter the quick-fix is applied:\n\n\n      a x+ [ahz]\n\nNew in 2022.1",
  "sources": [
    {
      "type": "file",
      "path": "src/main/resources/de/vette/idea/neos/xsd/xliff/xliff12.xsd",
      "language": "XML",
      "line": 7,
      "offset": 26,
      "length": 5,
      "code": {
        "startLine": 5,
        "length": 5,
        "offset": 94,
        "surroundingCode": "\t<xsd:simpleType name=\"XTend\">\n\t\t<xsd:restriction base=\"xsd:string\">\n\t\t\t<xsd:pattern value=\"x-[^\\s]+\"/>\n\t\t</xsd:restriction>\n\t</xsd:simpleType>"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "RegExpSimplifiable"
  },
  "hash": "99953da3ac9d7d0ff1fe851f975f83b33b85d341f560a5e9e24cd9f0f9298a8b"
},{
  "tool": "Code Inspection",
  "category": "Code style issues",
  "type": "'size() == 0' can be replaced with 'isEmpty()'",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "`text.length() == 0` can be replaced with 'text.isEmpty()'",
  "detailsInfo": "Reports `.size()` or `.length()` comparisons with a `0` literal that can be replaced with a call to `.isEmpty()`.\n\n**Example:**\n\n\n      boolean emptyList = list.size() == 0;\n\nAfter the quick-fix is applied:\n\n\n      boolean emptyList = list.isEmpty();\n      \n\nUse the **Ignored classes** table to add classes for which any `.size()` or `.length()` comparisons should not be replaced.\n\nUse the **Ignore expressions which would be replaced with `!isEmpty()`** option to ignore any expressions which would be replaced with `!isEmpty()`.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/FusionLazyElementType.java",
      "language": "JAVA",
      "line": 16,
      "offset": 29,
      "length": 18,
      "code": {
        "startLine": 14,
        "length": 18,
        "offset": 103,
        "surroundingCode": "    @Override\n    public @Nullable ASTNode createNode(CharSequence text) {\n        if (text == null || text.length() == 0) {\n            return null;\n        }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "SizeReplaceableByIsEmpty"
  },
  "hash": "1275af670b6ac62d3fbfce44470facbb68273c7ea711007411b0f6b946a0f76d"
},{
  "tool": "Code Inspection",
  "category": "Code style issues",
  "type": "'size() == 0' can be replaced with 'isEmpty()'",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "`text.length() == 0` can be replaced with 'text.isEmpty()'",
  "detailsInfo": "Reports `.size()` or `.length()` comparisons with a `0` literal that can be replaced with a call to `.isEmpty()`.\n\n**Example:**\n\n\n      boolean emptyList = list.size() == 0;\n\nAfter the quick-fix is applied:\n\n\n      boolean emptyList = list.isEmpty();\n      \n\nUse the **Ignored classes** table to add classes for which any `.size()` or `.length()` comparisons should not be replaced.\n\nUse the **Ignore expressions which would be replaced with `!isEmpty()`** option to ignore any expressions which would be replaced with `!isEmpty()`.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/afx/psi/AfxLazyElementType.java",
      "language": "JAVA",
      "line": 16,
      "offset": 29,
      "length": 18,
      "code": {
        "startLine": 14,
        "length": 18,
        "offset": 103,
        "surroundingCode": "    @Override\n    public @Nullable ASTNode createNode(CharSequence text) {\n        if (text == null || text.length() == 0) {\n            return null;\n        }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "SizeReplaceableByIsEmpty"
  },
  "hash": "8f9c082ef618d4f9fed68a784d00f3724997213e2a45c214284ebf44fae0b62f"
},{
  "tool": "Code Inspection",
  "category": "Performance",
  "type": "'String.equals()' can be replaced with 'String.isEmpty()'",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "`equals(\"\")` can be replaced with 'isEmpty()'",
  "detailsInfo": "Reports `equals()` being called to compare a `String` with an empty string. In this case, using `.isEmpty()` is better as it shows you exactly what you're checking.\n\n**Example:**\n\n\n      void checkString(String s){\n        if (\"\".equals(s)) throw new IllegalArgumentException();\n      }\n\nAfter the quick-fix is applied:\n\n\n      void checkString(String s){\n        if (s != null && s.isEmpty()) throw new IllegalArgumentException();\n      }\n\n\n`\"\".equals(str)` returns false when `str` is null. For safety, this inspection's quick-fix inserts an explicit\nnull-check when\nthe `equals()` argument is nullable. Use the option to make the inspection ignore such cases.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/stubs/FusionPropertyAssignmentStub.java",
      "language": "JAVA",
      "line": 74,
      "offset": 125,
      "length": 6,
      "code": {
        "startLine": 72,
        "length": 6,
        "offset": 243,
        "surroundingCode": "        @Override\n        public void indexStub(@NotNull FusionPropertyAssignmentStub stub, @NotNull IndexSink sink) {\n            if (stub.path == null || !stub.isSimpleProperty || stub.containingPrototype == null || stub.containingPrototype.equals(\"\")) {\n                return;\n            }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "StringEqualsEmptyString"
  },
  "hash": "d9fb1b4b88d731d11a5b024109cc2e2b5f1ec0152283048d3f2b710b2a63e735"
},{
  "tool": "Code Inspection",
  "category": "Compiler issues",
  "type": "Unchecked warning",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unchecked call to 'add(T)' as a member of raw type 'com.intellij.ui.CollectionListModel'",
  "detailsInfo": "Reports code on which an unchecked warning will be issued by the javac compiler. Every unchecked warning may potentially trigger `ClassCastException` at runtime.\n\nExample:\n\n\n      List items = Arrays.asList(\"string\", \"string\");\n      List<Integer> numbers = Collections.unmodifiableList(items); // unchecked assignment\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/SettingsForm.java",
      "language": "JAVA",
      "line": 183,
      "offset": 17,
      "length": 13,
      "code": {
        "startLine": 181,
        "length": 13,
        "offset": 35,
        "surroundingCode": "                }\n\n                this.list.add(text);\n            }\n        }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNCHECKED_WARNING"
  },
  "hash": "01e962949c465504fb38e7bb59b601417a0d357805eff999e580d8ba10cd9526"
},{
  "tool": "Code Inspection",
  "category": "Compiler issues",
  "type": "Unchecked warning",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unchecked assignment: 'com.intellij.ui.components.JBList' to 'javax.swing.JList'",
  "detailsInfo": "Reports code on which an unchecked warning will be issued by the javac compiler. Every unchecked warning may potentially trigger `ClassCastException` at runtime.\n\nExample:\n\n\n      List items = Arrays.asList(\"string\", \"string\");\n      List<Integer> numbers = Collections.unmodifiableList(items); // unchecked assignment\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/SettingsForm.java",
      "language": "JAVA",
      "line": 85,
      "offset": 74,
      "length": 10,
      "code": {
        "startLine": 83,
        "length": 10,
        "offset": 117,
        "surroundingCode": "        localeList.setModel(this.locales);\n\n        ToolbarDecorator editableList = ToolbarDecorator.createDecorator(localeList);\n        editableList.disableUpDownActions();\n        editableList.setPreferredSize(new Dimension(150, 100));"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNCHECKED_WARNING"
  },
  "hash": "10f2557cb9b3fb86039406d2e10ccf1e5f63961b8d2b12b4e3f9df2a7fe444a1"
},{
  "tool": "Code Inspection",
  "category": "Compiler issues",
  "type": "Unchecked warning",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unchecked call to 'ArrayList(Collection)' as a member of raw type 'java.util.ArrayList'",
  "detailsInfo": "Reports code on which an unchecked warning will be issued by the javac compiler. Every unchecked warning may potentially trigger `ClassCastException` at runtime.\n\nExample:\n\n\n      List items = Arrays.asList(\"string\", \"string\");\n      List<Integer> numbers = Collections.unmodifiableList(items); // unchecked assignment\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/refactoring/MovePrototypeToFile.java",
      "language": "JAVA",
      "line": 113,
      "offset": 57,
      "length": 11,
      "code": {
        "startLine": 111,
        "length": 11,
        "offset": 152,
        "surroundingCode": "\n    public static List<FusionPrototypeSignature> findAllPrototypeSignatures(PsiFile psiFile) {\n        List<FusionPrototypeSignature> signatures = new ArrayList<>(PsiTreeUtil.findChildrenOfType(psiFile, FusionPrototypeSignature.class));\n        return signatures.stream().filter(MovePrototypeToFile::isTopLevelPrototype).collect(Collectors.toList());\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNCHECKED_WARNING"
  },
  "hash": "427efb7b1adf7608b250112cbe65a1def78e3b41e9ce82f0e5d8a6104cf13749"
},{
  "tool": "Code Inspection",
  "category": "Compiler issues",
  "type": "Unchecked warning",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unchecked generics array creation for varargs parameter",
  "detailsInfo": "Reports code on which an unchecked warning will be issued by the javac compiler. Every unchecked warning may potentially trigger `ClassCastException` at runtime.\n\nExample:\n\n\n      List items = Arrays.asList(\"string\", \"string\");\n      List<Integer> numbers = Collections.unmodifiableList(items); // unchecked assignment\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/config/yaml/YamlElementPatternHelper.java",
      "language": "JAVA",
      "line": 37,
      "offset": 48,
      "length": 26,
      "code": {
        "startLine": 35,
        "length": 26,
        "offset": 109,
        "surroundingCode": "                //   <caret>\n                PlatformPatterns\n                        .psiElement().with(new ParentPathPatternCondition(\n                        YAMLScalar.class, YAMLMapping.class,\n                        YAMLKeyValue.class, YAMLMapping.class,"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNCHECKED_WARNING"
  },
  "hash": "55b746c90d218365cabd84e3e6c869077e69e567c93613060bea4ffa30432ce4"
},{
  "tool": "Code Inspection",
  "category": "Compiler issues",
  "type": "Unchecked warning",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unchecked call to 'setModel(ComboBoxModel)' as a member of raw type 'javax.swing.JComboBox'",
  "detailsInfo": "Reports code on which an unchecked warning will be issued by the javac compiler. Every unchecked warning may potentially trigger `ClassCastException` at runtime.\n\nExample:\n\n\n      List items = Arrays.asList(\"string\", \"string\");\n      List<Integer> numbers = Collections.unmodifiableList(items); // unchecked assignment\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/refactoring/MovePrototypeDialog.java",
      "language": "JAVA",
      "line": 272,
      "offset": 9,
      "length": 34,
      "code": {
        "startLine": 270,
        "length": 34,
        "offset": 101,
        "surroundingCode": "        Set<String> items = new LinkedHashSet<>();\n        appendPossibleTargetFiles(items);\n        field.getChildComponent().setModel(new DefaultComboBoxModel<String>(items.toArray(String[]::new)));\n        String title = FusionBundle.message(\"refactoring.move.prototype.target.file\");\n        FileChooserDescriptor descriptor = FileChooserDescriptorFactory.createSingleLocalFileDescriptor()"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNCHECKED_WARNING"
  },
  "hash": "5a70baf1354609c2c56278c416ada7358843a16637591c8c23f6432f1041bcbf"
},{
  "tool": "Code Inspection",
  "category": "Compiler issues",
  "type": "Unchecked warning",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unchecked call to 'Capture(InitialPatternCondition)' as a member of raw type 'de.vette.idea.neos.lang.fusion.patterns.FusionElementPattern.Capture'",
  "detailsInfo": "Reports code on which an unchecked warning will be issued by the javac compiler. Every unchecked warning may potentially trigger `ClassCastException` at runtime.\n\nExample:\n\n\n      List items = Arrays.asList(\"string\", \"string\");\n      List<Integer> numbers = Collections.unmodifiableList(items); // unchecked assignment\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/patterns/FusionPatterns.java",
      "language": "JAVA",
      "line": 32,
      "offset": 20,
      "length": 7,
      "code": {
        "startLine": 30,
        "length": 7,
        "offset": 101,
        "surroundingCode": "\n    public static FusionElementPattern fusionValueDsl(final String identifier) {\n        return new Capture(new InitialPatternCondition<FusionValueDslContent>(FusionValueDslContent.class) {\n            public boolean accepts(@Nullable Object o, ProcessingContext context) {\n                if (o instanceof FusionValueDslContent) {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNCHECKED_WARNING"
  },
  "hash": "8d25d3f4130d568e7a481b62637c2c52cd99ccc6accd29eefb88be1f153143d5"
},{
  "tool": "Code Inspection",
  "category": "Compiler issues",
  "type": "Unchecked warning",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unchecked generics array creation for varargs parameter",
  "detailsInfo": "Reports code on which an unchecked warning will be issued by the javac compiler. Every unchecked warning may potentially trigger `ClassCastException` at runtime.\n\nExample:\n\n\n      List items = Arrays.asList(\"string\", \"string\");\n      List<Integer> numbers = Collections.unmodifiableList(items); // unchecked assignment\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/config/yaml/YamlElementPatternHelper.java",
      "language": "JAVA",
      "line": 56,
      "offset": 56,
      "length": 26,
      "code": {
        "startLine": 54,
        "length": 26,
        "offset": 111,
        "surroundingCode": "                // foo:\n                //   fo<caret>:\n                PlatformPatterns.psiElement().with(new ParentPathPatternCondition(\n                        YAMLKeyValue.class, YAMLMapping.class,\n                        YAMLKeyValue.class, YAMLMapping.class,"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNCHECKED_WARNING"
  },
  "hash": "abb80eeba6e2df40d28276566e100c2e981ee5c1cea306cf532fdd574b68e8bf"
},{
  "tool": "Code Inspection",
  "category": "Compiler issues",
  "type": "Unchecked warning",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unchecked assignment: 'java.util.ArrayList' to 'java.util.List'",
  "detailsInfo": "Reports code on which an unchecked warning will be issued by the javac compiler. Every unchecked warning may potentially trigger `ClassCastException` at runtime.\n\nExample:\n\n\n      List items = Arrays.asList(\"string\", \"string\");\n      List<Integer> numbers = Collections.unmodifiableList(items); // unchecked assignment\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/refactoring/MovePrototypeToFile.java",
      "language": "JAVA",
      "line": 113,
      "offset": 57,
      "length": 11,
      "code": {
        "startLine": 111,
        "length": 11,
        "offset": 152,
        "surroundingCode": "\n    public static List<FusionPrototypeSignature> findAllPrototypeSignatures(PsiFile psiFile) {\n        List<FusionPrototypeSignature> signatures = new ArrayList<>(PsiTreeUtil.findChildrenOfType(psiFile, FusionPrototypeSignature.class));\n        return signatures.stream().filter(MovePrototypeToFile::isTopLevelPrototype).collect(Collectors.toList());\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNCHECKED_WARNING"
  },
  "hash": "bd849734df7df132ca81a271af392fcf4063530bbf50264e42a56df5ff4f9e4d"
},{
  "tool": "Code Inspection",
  "category": "Compiler issues",
  "type": "Unchecked warning",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unchecked call to 'setModel(ListModel)' as a member of raw type 'javax.swing.JList'",
  "detailsInfo": "Reports code on which an unchecked warning will be issued by the javac compiler. Every unchecked warning may potentially trigger `ClassCastException` at runtime.\n\nExample:\n\n\n      List items = Arrays.asList(\"string\", \"string\");\n      List<Integer> numbers = Collections.unmodifiableList(items); // unchecked assignment\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/SettingsForm.java",
      "language": "JAVA",
      "line": 83,
      "offset": 9,
      "length": 19,
      "code": {
        "startLine": 81,
        "length": 19,
        "offset": 59,
        "surroundingCode": "\n        JBList localeList = new JBList<String>();\n        localeList.setModel(this.locales);\n\n        ToolbarDecorator editableList = ToolbarDecorator.createDecorator(localeList);"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNCHECKED_WARNING"
  },
  "hash": "e396fe2dd686f7f75557a67117d34d812f951c697eb97482bb94301050ca351c"
},{
  "tool": "Code Inspection",
  "category": "Compiler issues",
  "type": "Unchecked warning",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unchecked generics array creation for varargs parameter",
  "detailsInfo": "Reports code on which an unchecked warning will be issued by the javac compiler. Every unchecked warning may potentially trigger `ClassCastException` at runtime.\n\nExample:\n\n\n      List items = Arrays.asList(\"string\", \"string\");\n      List<Integer> numbers = Collections.unmodifiableList(items); // unchecked assignment\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/config/yaml/YamlElementPatternHelper.java",
      "language": "JAVA",
      "line": 49,
      "offset": 37,
      "length": 26,
      "code": {
        "startLine": 47,
        "length": 26,
        "offset": 166,
        "surroundingCode": "                        .psiElement().afterLeaf(\n                        PlatformPatterns.psiElement(YAMLTokenTypes.INDENT).with(\n                                new ParentPathPatternCondition(YAMLKeyValue.class, YAMLMapping.class, YAMLDocument.class)\n                        )\n                )"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNCHECKED_WARNING"
  },
  "hash": "f7a75ca0bc9c6c39b05632fd1e1c84dff7e3663413cae7d6a4b0dce9483425dc"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import com.intellij.psi.impl.source.parsing.xml.XmlParser;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/xliff/XliffParserDefinition.java",
      "language": "JAVA",
      "line": 11,
      "offset": 1,
      "length": 58,
      "code": {
        "startLine": 9,
        "length": 58,
        "offset": 69,
        "surroundingCode": "import com.intellij.psi.PsiElement;\nimport com.intellij.psi.PsiFile;\nimport com.intellij.psi.impl.source.parsing.xml.XmlParser;\nimport com.intellij.psi.tree.IFileElementType;\nimport com.intellij.psi.tree.TokenSet;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "08243d2ff2b61cafdac31e7ff87c66f9cc65b87360df6802ef32b21acee1d357"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import de.vette.idea.neos.lang.fusion.psi.*;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/ext/FusionPropertyAssignmentImplMixin.java",
      "language": "JAVA",
      "line": 27,
      "offset": 1,
      "length": 44,
      "code": {
        "startLine": 25,
        "length": 44,
        "offset": 93,
        "surroundingCode": "import com.intellij.psi.tree.TokenSet;\nimport com.intellij.util.IncorrectOperationException;\nimport de.vette.idea.neos.lang.fusion.psi.*;\nimport de.vette.idea.neos.lang.fusion.psi.impl.FusionStubbedElementImpl;\nimport de.vette.idea.neos.lang.fusion.stubs.FusionPropertyAssignmentStub;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "119f244972d24dc78e6a1099db4a5c5ad1f3b995e82ba3c6a36da6e859108652"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import com.intellij.util.IncorrectOperationException;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/FusionNamedElementImpl.java",
      "language": "JAVA",
      "line": 25,
      "offset": 1,
      "length": 53,
      "code": {
        "startLine": 23,
        "length": 53,
        "offset": 84,
        "surroundingCode": "import com.intellij.psi.PsiElement;\nimport com.intellij.psi.PsiNameIdentifierOwner;\nimport com.intellij.util.IncorrectOperationException;\nimport de.vette.idea.neos.lang.fusion.psi.FusionNamedElement;\nimport org.jetbrains.annotations.NonNls;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "218d6568b0a8c023ccc9bf01a28832c75803a041c70650b75b51b5adbaf83c44"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import org.jetbrains.annotations.Nullable;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/FusionNamedElementImpl.java",
      "language": "JAVA",
      "line": 29,
      "offset": 1,
      "length": 42,
      "code": {
        "startLine": 27,
        "length": 42,
        "offset": 83,
        "surroundingCode": "import org.jetbrains.annotations.NonNls;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\nimport javax.swing.*;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "2781b9a1e7024d6415d3fe78c21e99ea78dce6f3931042bd5e912a596923271f"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import de.vette.idea.neos.lang.fusion.psi.*;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/ext/FusionPrototypeInstanceImplMixin.java",
      "language": "JAVA",
      "line": 22,
      "offset": 1,
      "length": 44,
      "code": {
        "startLine": 20,
        "length": 44,
        "offset": 76,
        "surroundingCode": "import com.intellij.lang.ASTNode;\nimport com.intellij.psi.util.PsiTreeUtil;\nimport de.vette.idea.neos.lang.fusion.psi.*;\nimport de.vette.idea.neos.lang.fusion.psi.impl.FusionElementImpl;\nimport org.jetbrains.annotations.NotNull;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "2b17f002ed15512de535c3544a7c86110c8e5b501a9b3d8adaf6e63c4a3e0cf1"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import de.vette.idea.neos.lang.fusion.FusionFileType;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/actions/XliffCreateFromTemplateHandler.java",
      "language": "JAVA",
      "line": 6,
      "offset": 1,
      "length": 53,
      "code": {
        "startLine": 4,
        "length": 53,
        "offset": 125,
        "surroundingCode": "import com.intellij.ide.fileTemplates.DefaultTemplatePropertiesProvider;\nimport com.intellij.ide.fileTemplates.FileTemplate;\nimport de.vette.idea.neos.lang.fusion.FusionFileType;\nimport de.vette.idea.neos.lang.xliff.XliffFileType;\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "39d1a35c1fcd43df4093c7cf54dcf3a9aa57aa31e7b31063435df2bd697fe3b6"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import com.intellij.navigation.ItemPresentation;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/FusionNamedElementImpl.java",
      "language": "JAVA",
      "line": 22,
      "offset": 1,
      "length": 48,
      "code": {
        "startLine": 20,
        "length": 48,
        "offset": 35,
        "surroundingCode": "\nimport com.intellij.lang.ASTNode;\nimport com.intellij.navigation.ItemPresentation;\nimport com.intellij.psi.PsiElement;\nimport com.intellij.psi.PsiNameIdentifierOwner;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "3ed7e4fec0f7ad547088355efd6ca281ea5b596f70fcf50d0a5b74a61f4e50ab"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import com.intellij.lang.html.HTMLLanguage;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/xliff/XliffLanguage.java",
      "language": "JAVA",
      "line": 4,
      "offset": 1,
      "length": 43,
      "code": {
        "startLine": 2,
        "length": 43,
        "offset": 36,
        "surroundingCode": "\nimport com.intellij.lang.Language;\nimport com.intellij.lang.html.HTMLLanguage;\nimport com.intellij.lang.xml.XMLLanguage;\nimport org.jetbrains.annotations.NonNls;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "4562032d2b6df2c460e7a36b12d003e4db813bb4faf14cd0afbc1efb68bf163d"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import de.vette.idea.neos.lang.fusion.psi.*;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/annotators/NodeTypeLineMarkerProvider.java",
      "language": "JAVA",
      "line": 26,
      "offset": 1,
      "length": 44,
      "code": {
        "startLine": 24,
        "length": 44,
        "offset": 73,
        "surroundingCode": "import com.intellij.psi.PsiElement;\nimport de.vette.idea.neos.NeosIcons;\nimport de.vette.idea.neos.lang.fusion.psi.*;\nimport de.vette.idea.neos.lang.fusion.resolve.ResolveEngine;\nimport org.jetbrains.annotations.NotNull;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "46f0674b861ef8a477e78379774610d07e5cb7ae42f0a8d7aa7fb65b9df3a54b"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import de.vette.idea.neos.lang.fusion.FusionBundle;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/xliff/XliffBundle.java",
      "language": "JAVA",
      "line": 4,
      "offset": 1,
      "length": 51,
      "code": {
        "startLine": 2,
        "length": 51,
        "offset": 36,
        "surroundingCode": "\nimport com.intellij.DynamicBundle;\nimport de.vette.idea.neos.lang.fusion.FusionBundle;\nimport org.jetbrains.annotations.Nls;\nimport org.jetbrains.annotations.NotNull;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "4f1df89676295cdf0bf56a0dc22c5197f4095112ef4a31f8d348e005c92717c8"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import java.util.Map;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/actions/XliffCreateFromTemplateHandler.java",
      "language": "JAVA",
      "line": 9,
      "offset": 1,
      "length": 21,
      "code": {
        "startLine": 7,
        "length": 21,
        "offset": 53,
        "surroundingCode": "import de.vette.idea.neos.lang.xliff.XliffFileType;\n\nimport java.util.Map;\n\npublic class XliffCreateFromTemplateHandler extends DefaultCreateFromTemplateHandler {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "5209c27e5bacc6009a616f74cb84dae0ad7e9b78bd0564ed19211ef15d195b26"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import com.intellij.ide.fileTemplates.DefaultTemplatePropertiesProvider;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/actions/XliffCreateFromTemplateHandler.java",
      "language": "JAVA",
      "line": 4,
      "offset": 1,
      "length": 72,
      "code": {
        "startLine": 2,
        "length": 72,
        "offset": 73,
        "surroundingCode": "\nimport com.intellij.ide.fileTemplates.DefaultCreateFromTemplateHandler;\nimport com.intellij.ide.fileTemplates.DefaultTemplatePropertiesProvider;\nimport com.intellij.ide.fileTemplates.FileTemplate;\nimport de.vette.idea.neos.lang.fusion.FusionFileType;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "538b05f7900049b28786e802e16c6ee5788d6eb8ae1cee3bbe67fe2b8bc5503c"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import de.vette.idea.neos.lang.fusion.psi.*;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/stubs/FusionPropertyAssignmentStub.java",
      "language": "JAVA",
      "line": 22,
      "offset": 1,
      "length": 44,
      "code": {
        "startLine": 20,
        "length": 44,
        "offset": 34,
        "surroundingCode": "\nimport com.intellij.psi.stubs.*;\nimport de.vette.idea.neos.lang.fusion.psi.*;\nimport de.vette.idea.neos.lang.fusion.psi.impl.FusionPropertyAssignmentImpl;\nimport de.vette.idea.neos.lang.fusion.stubs.index.FusionPropertyAssignmentIndex;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "5ce2fd52b4a1413fcfa84f1abfec5ff76a1ec551f2cf13259fdd975234391e6e"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import com.intellij.psi.PsiElement;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/FusionNamedElementImpl.java",
      "language": "JAVA",
      "line": 23,
      "offset": 1,
      "length": 35,
      "code": {
        "startLine": 21,
        "length": 35,
        "offset": 83,
        "surroundingCode": "import com.intellij.lang.ASTNode;\nimport com.intellij.navigation.ItemPresentation;\nimport com.intellij.psi.PsiElement;\nimport com.intellij.psi.PsiNameIdentifierOwner;\nimport com.intellij.util.IncorrectOperationException;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "695a1dff7374747f1b6c577a6d6b98922f2cb3915637078c06350298373433dc"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import com.google.gson.JsonElement;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/NeosProjectService.java",
      "language": "JAVA",
      "line": 21,
      "offset": 1,
      "length": 35,
      "code": {
        "startLine": 19,
        "length": 35,
        "offset": 29,
        "surroundingCode": "package de.vette.idea.neos;\n\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonObject;\nimport com.intellij.ide.plugins.newui.SearchQueryParser;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "71fce0e8fb82f61f7d842d57f91b4a03ba8380e6d5f23f9b0dce311e4c034cbd"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import com.intellij.openapi.vfs.VfsUtil;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/NeosProjectService.java",
      "language": "JAVA",
      "line": 26,
      "offset": 1,
      "length": 40,
      "code": {
        "startLine": 24,
        "length": 40,
        "offset": 92,
        "surroundingCode": "import com.intellij.openapi.diagnostic.Logger;\nimport com.intellij.openapi.project.Project;\nimport com.intellij.openapi.vfs.VfsUtil;\nimport com.intellij.openapi.vfs.VirtualFile;\nimport com.intellij.psi.PsiElement;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "722c5f8c6b3f9e1419ccdc897ececfca391469150669cc25eaf4482ced1e6436"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import de.vette.idea.neos.lang.fusion.icons.FusionIcons;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/actions/CreateXliffFile.java",
      "language": "JAVA",
      "line": 9,
      "offset": 1,
      "length": 56,
      "code": {
        "startLine": 7,
        "length": 56,
        "offset": 75,
        "surroundingCode": "import com.intellij.psi.PsiDirectory;\nimport de.vette.idea.neos.NeosIcons;\nimport de.vette.idea.neos.lang.fusion.icons.FusionIcons;\nimport de.vette.idea.neos.lang.xliff.XliffIcons;\nimport org.jetbrains.annotations.NotNull;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "72fc2c9f09d88ddcdb6866552ecf6443ec25d65c0251f26bb3ea28f23533a313"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import com.intellij.psi.PsiNameIdentifierOwner;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/FusionNamedElementImpl.java",
      "language": "JAVA",
      "line": 24,
      "offset": 1,
      "length": 47,
      "code": {
        "startLine": 22,
        "length": 47,
        "offset": 85,
        "surroundingCode": "import com.intellij.navigation.ItemPresentation;\nimport com.intellij.psi.PsiElement;\nimport com.intellij.psi.PsiNameIdentifierOwner;\nimport com.intellij.util.IncorrectOperationException;\nimport de.vette.idea.neos.lang.fusion.psi.FusionNamedElement;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "836db5cfbb217c6584e848fe2b6e9147b7d6a8a4d4e1ad6cc93b695ab209c955"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import com.intellij.ide.plugins.newui.SearchQueryParser;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/NeosProjectService.java",
      "language": "JAVA",
      "line": 23,
      "offset": 1,
      "length": 56,
      "code": {
        "startLine": 21,
        "length": 56,
        "offset": 71,
        "surroundingCode": "import com.google.gson.JsonElement;\nimport com.google.gson.JsonObject;\nimport com.intellij.ide.plugins.newui.SearchQueryParser;\nimport com.intellij.openapi.diagnostic.Logger;\nimport com.intellij.openapi.project.Project;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "861d919fb61cd4efbc9462b1965b9f43b0a8bf1b0ec89f2b936aaed931f044c3"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import com.intellij.psi.tree.IElementType;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/xliff/XliffFile.java",
      "language": "JAVA",
      "line": 5,
      "offset": 1,
      "length": 42,
      "code": {
        "startLine": 3,
        "length": 42,
        "offset": 95,
        "surroundingCode": "import com.intellij.psi.FileViewProvider;\nimport com.intellij.psi.impl.source.xml.XmlFileImpl;\nimport com.intellij.psi.tree.IElementType;\nimport com.intellij.psi.tree.IFileElementType;\nimport com.intellij.psi.xml.XmlFile;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "8fc6df3735c008578d405e36ba47c56649031bf3ea8784d04b1c447fa945b616"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import javax.swing.*;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/FusionNamedElementImpl.java",
      "language": "JAVA",
      "line": 31,
      "offset": 1,
      "length": 21,
      "code": {
        "startLine": 29,
        "length": 21,
        "offset": 44,
        "surroundingCode": "import org.jetbrains.annotations.Nullable;\n\nimport javax.swing.*;\n\npublic abstract class FusionNamedElementImpl extends FusionElementImpl implements FusionNamedElement {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "9072f5ac552738bc782e1bdac93fb69fc4e40b7fe817b12d7a32b9ecd2511e32"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import de.vette.idea.neos.lang.fusion.psi.*;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/usages/PrototypeFindUsagesProvider.java",
      "language": "JAVA",
      "line": 27,
      "offset": 1,
      "length": 44,
      "code": {
        "startLine": 25,
        "length": 44,
        "offset": 97,
        "surroundingCode": "import com.intellij.psi.tree.TokenSet;\nimport de.vette.idea.neos.lang.fusion.FusionLexerAdapter;\nimport de.vette.idea.neos.lang.fusion.psi.*;\nimport org.jetbrains.annotations.Nls;\nimport org.jetbrains.annotations.NonNls;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "9345714354dca6f142dfdcacc8851562b9c240fdd3d7105f9e7d54ff66e56df2"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import de.vette.idea.neos.lang.fusion.psi.*;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/usages/UsagesTypeProvider.java",
      "language": "JAVA",
      "line": 25,
      "offset": 1,
      "length": 44,
      "code": {
        "startLine": 23,
        "length": 44,
        "offset": 109,
        "surroundingCode": "import com.intellij.usages.impl.rules.UsageTypeProvider;\nimport de.vette.idea.neos.lang.fusion.FusionBundle;\nimport de.vette.idea.neos.lang.fusion.psi.*;\nimport org.jetbrains.annotations.Nullable;\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "951755b44e911730b5e4ff764b292513b3fafe6ae8bc16a3ed58855bde2c0e63"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import java.util.ResourceBundle;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/LocaleDialogWrapper.java",
      "language": "JAVA",
      "line": 12,
      "offset": 1,
      "length": 32,
      "code": {
        "startLine": 10,
        "length": 32,
        "offset": 23,
        "surroundingCode": "\nimport javax.swing.*;\nimport java.util.ResourceBundle;\nimport java.util.regex.Pattern;\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "954e0c8e73c0fb4fe3cbdd4889b7ef18043c4ee73ecda8faf86fcbc09f1f9518"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import de.vette.idea.neos.lang.fusion.psi.*;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/ext/FusionPathImplMixin.java",
      "language": "JAVA",
      "line": 22,
      "offset": 1,
      "length": 44,
      "code": {
        "startLine": 20,
        "length": 44,
        "offset": 70,
        "surroundingCode": "import com.intellij.lang.ASTNode;\nimport com.intellij.psi.PsiElement;\nimport de.vette.idea.neos.lang.fusion.psi.*;\nimport de.vette.idea.neos.lang.fusion.psi.impl.FusionElementImpl;\nimport org.jetbrains.annotations.NotNull;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "998a9a9776ad9e59593ce379af58966900c14f6c6b3dbe7c8dcd8e3e959f0b8b"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import de.vette.idea.neos.NeosIcons;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/actions/CreateXliffFile.java",
      "language": "JAVA",
      "line": 8,
      "offset": 1,
      "length": 36,
      "code": {
        "startLine": 6,
        "length": 36,
        "offset": 83,
        "surroundingCode": "import com.intellij.openapi.project.Project;\nimport com.intellij.psi.PsiDirectory;\nimport de.vette.idea.neos.NeosIcons;\nimport de.vette.idea.neos.lang.fusion.icons.FusionIcons;\nimport de.vette.idea.neos.lang.xliff.XliffIcons;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "9ff536e19a9442336a232332a2d2f584637dad1a5935a4f9cef21f4dd45d2098"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import java.util.List;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/NeosProjectService.java",
      "language": "JAVA",
      "line": 37,
      "offset": 1,
      "length": 22,
      "code": {
        "startLine": 35,
        "length": 22,
        "offset": 29,
        "surroundingCode": "\nimport java.io.IOException;\nimport java.util.List;\n\nimport static com.intellij.openapi.project.ProjectUtil.guessProjectDir;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "ab6a9b24c06de5c545045b6bf580e1efc0c91904ff86852dda53115ba57ec5ab"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import java.util.ArrayList;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/eel/resolve/ref/EelCompositeIdentifierReference.java",
      "language": "JAVA",
      "line": 11,
      "offset": 1,
      "length": 27,
      "code": {
        "startLine": 9,
        "length": 27,
        "offset": 43,
        "surroundingCode": "import org.jetbrains.annotations.NotNull;\n\nimport java.util.ArrayList;\nimport java.util.List;\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "ac709f3597b9046d10da7d737ccbb666980dd3c6a6908e8b81a3344b21564bdc"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import static com.intellij.openapi.project.ProjectUtil.guessProjectDir;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/NeosProjectService.java",
      "language": "JAVA",
      "line": 39,
      "offset": 1,
      "length": 71,
      "code": {
        "startLine": 37,
        "length": 71,
        "offset": 24,
        "surroundingCode": "import java.util.List;\n\nimport static com.intellij.openapi.project.ProjectUtil.guessProjectDir;\n\npublic class NeosProjectService {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "bcf2078ce8ddbdd78738adb9ef7142891e9ce0fd3111092a144e260c56d9c639"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import de.vette.idea.neos.lang.fusion.psi.*;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/editor/FusionBreadcrumbsInfoProvider.java",
      "language": "JAVA",
      "line": 27,
      "offset": 1,
      "length": 44,
      "code": {
        "startLine": 25,
        "length": 44,
        "offset": 111,
        "surroundingCode": "import de.vette.idea.neos.lang.fusion.FusionLanguage;\nimport de.vette.idea.neos.lang.fusion.icons.FusionIcons;\nimport de.vette.idea.neos.lang.fusion.psi.*;\nimport de.vette.idea.neos.lang.fusion.psi.FusionBlock;\nimport org.jetbrains.annotations.NotNull;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "be1118e9c9c4be57d817a88e31f806d95449a7f2246e335896b1d4b34428ea6d"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import com.intellij.psi.PsiNamedElement;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/FusionNamedElement.java",
      "language": "JAVA",
      "line": 23,
      "offset": 1,
      "length": 40,
      "code": {
        "startLine": 21,
        "length": 40,
        "offset": 95,
        "surroundingCode": "import com.intellij.psi.NavigatablePsiElement;\nimport com.intellij.psi.PsiNameIdentifierOwner;\nimport com.intellij.psi.PsiNamedElement;\n\npublic interface FusionNamedElement extends FusionElement, PsiNameIdentifierOwner, NavigatablePsiElement {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "c05a6e18e4865265b12d6ca923a47b9bdd29c92524a6f75c0ba999db224cd6c4"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import de.vette.idea.neos.lang.fusion.psi.*;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/stubs/FusionPrototypeSignatureStub.java",
      "language": "JAVA",
      "line": 22,
      "offset": 1,
      "length": 44,
      "code": {
        "startLine": 20,
        "length": 44,
        "offset": 34,
        "surroundingCode": "\nimport com.intellij.psi.stubs.*;\nimport de.vette.idea.neos.lang.fusion.psi.*;\nimport de.vette.idea.neos.lang.fusion.psi.impl.FusionPrototypeSignatureImpl;\nimport de.vette.idea.neos.lang.fusion.stubs.index.FusionPrototypeDeclarationIndex;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "c26e15e8015668a9d0ab2a8dbfc90261121541f68ecd20a200adb7bdae2ab090"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import com.jetbrains.php.composer.InstalledPackageData;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/NeosProjectService.java",
      "language": "JAVA",
      "line": 32,
      "offset": 1,
      "length": 55,
      "code": {
        "startLine": 30,
        "length": 55,
        "offset": 104,
        "surroundingCode": "import com.jetbrains.php.composer.ComposerDataService;\nimport com.jetbrains.php.composer.ComposerUtils;\nimport com.jetbrains.php.composer.InstalledPackageData;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "c63d7fa134994c77fa923f89f050de209b37e710484605a2905bc05d0e7a4645"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import de.vette.idea.neos.lang.fusion.psi.*;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/resolve/ResolveEngine.java",
      "language": "JAVA",
      "line": 33,
      "offset": 1,
      "length": 44,
      "code": {
        "startLine": 31,
        "length": 44,
        "offset": 117,
        "surroundingCode": "import de.vette.idea.neos.indexes.DefaultContextFileIndex;\nimport de.vette.idea.neos.indexes.NodeTypesYamlFileIndex;\nimport de.vette.idea.neos.lang.fusion.psi.*;\nimport de.vette.idea.neos.lang.fusion.stubs.index.FusionNamespaceDeclarationIndex;\nimport de.vette.idea.neos.lang.fusion.stubs.index.FusionPrototypeDeclarationIndex;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "cbd466dd8e3314b08b1b408e78923c7ddac2c47e9974e97a53561b769c849e1c"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import com.jetbrains.php.composer.ComposerUtils;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/NeosProjectService.java",
      "language": "JAVA",
      "line": 31,
      "offset": 1,
      "length": 48,
      "code": {
        "startLine": 29,
        "length": 48,
        "offset": 110,
        "surroundingCode": "import com.jetbrains.php.composer.ComposerConfigUtils;\nimport com.jetbrains.php.composer.ComposerDataService;\nimport com.jetbrains.php.composer.ComposerUtils;\nimport com.jetbrains.php.composer.InstalledPackageData;\nimport org.jetbrains.annotations.NotNull;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "d13e30dc6795e3a9d3140a4e40f5b1390eaa6956122e1a79e0b9ea55ebff5c08"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import org.jetbrains.annotations.NonNls;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/FusionNamedElementImpl.java",
      "language": "JAVA",
      "line": 27,
      "offset": 1,
      "length": 40,
      "code": {
        "startLine": 25,
        "length": 40,
        "offset": 116,
        "surroundingCode": "import com.intellij.util.IncorrectOperationException;\nimport de.vette.idea.neos.lang.fusion.psi.FusionNamedElement;\nimport org.jetbrains.annotations.NonNls;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "dc6bd5e6ac23bc6f6f512ea1c311958fd46789bc6b9eeb1d4eddceba5ed65af9"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import com.intellij.openapi.fileTypes.FileType;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/actions/TranslateNodeTypeAction.java",
      "language": "JAVA",
      "line": 9,
      "offset": 1,
      "length": 47,
      "code": {
        "startLine": 7,
        "length": 47,
        "offset": 100,
        "surroundingCode": "import com.intellij.openapi.actionSystem.*;\nimport com.intellij.openapi.command.WriteCommandAction;\nimport com.intellij.openapi.fileTypes.FileType;\nimport com.intellij.openapi.fileTypes.FileTypeManager;\nimport com.intellij.openapi.fileTypes.FileTypeRegistry;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "e95fe5bd3d3a2100a41a22830def73f6dc878a69ff863f948ebab4bb0df7d2fd"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import de.vette.idea.neos.util.NeosUtil;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/php/inspections/suppression/FlowUnusedMethodSuppressor.java",
      "language": "JAVA",
      "line": 9,
      "offset": 1,
      "length": 40,
      "code": {
        "startLine": 7,
        "length": 40,
        "offset": 97,
        "surroundingCode": "import com.jetbrains.php.lang.psi.elements.Method;\nimport de.vette.idea.neos.NeosProjectService;\nimport de.vette.idea.neos.util.NeosUtil;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "ecf74169f3b209d3e3129d3473f30ab2e368e8218ce11ff8ced3a56cae8849cc"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import org.snakeyaml.engine.v2.schema.JsonSchema;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/config/yaml/schema/NodeTypePresetYamlSchemaProvider.java",
      "language": "JAVA",
      "line": 14,
      "offset": 1,
      "length": 49,
      "code": {
        "startLine": 12,
        "length": 49,
        "offset": 85,
        "surroundingCode": "import org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\nimport org.snakeyaml.engine.v2.schema.JsonSchema;\n\nimport java.util.Objects;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "f4c3611c0eb928e45531783108d7825030217bc807890ad8cf108c6813da2f84"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Unused import `import de.vette.idea.neos.lang.afx.psi.AfxTag;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/afx/AfxInspectionSuppressor.java",
      "language": "JAVA",
      "line": 9,
      "offset": 1,
      "length": 46,
      "code": {
        "startLine": 7,
        "length": 46,
        "offset": 95,
        "surroundingCode": "import com.intellij.psi.xml.XmlAttributeValue;\nimport de.vette.idea.neos.lang.afx.psi.AfxFile;\nimport de.vette.idea.neos.lang.afx.psi.AfxTag;\nimport org.jetbrains.annotations.NotNull;\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "ffb539b37a3aeaa8eebb831e180aa5874315bb55cc305f787166ec5dd8ba4f92"
},{
  "tool": "Code Inspection",
  "category": "Code style issues",
  "type": "Unnecessary modifier",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Modifier `private` is redundant for enum constructors",
  "detailsInfo": "Reports redundant modifiers and suggests to remove them. The resulting code will be shorter, but the behaviour and meaning will remain the same.\n\n**Example 1:**\n\n\n      // all code is implicitly strictfp under Java 17 and higher\n      strictfp class X {\n\n        // inner enums are implicitly static\n        static enum Inner {\n            A, B, C\n        }\n\n        // inner records are implicitly static\n        static record R() {\n        }\n      }\n\n**Example 2:**\n\n\n      final record R() {\n        // all records are implicitly final\n      }\n\n**Example 3:**\n\n\n      // all interfaces are implicitly abstract\n      abstract interface Printer {\n\n        // all interface members are implicitly public\n        public int size();\n\n        // all inner classes of interfaces are implicitly static\n        static class Inner {}\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/afx/formatter/AfxAttributeValuePresentation.java",
      "language": "JAVA",
      "line": 14,
      "offset": 5,
      "length": 7,
      "code": {
        "startLine": 12,
        "length": 7,
        "offset": 52,
        "surroundingCode": "    private final String myPresentableTextKey;\n\n    private AfxAttributeValuePresentation(String stored, String presentableTextKey) {\n        this.myStored = stored;\n        this.myPresentableTextKey = presentableTextKey;"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UnnecessaryModifier"
  },
  "hash": "3e9ffe5a0fd2a93e5bc993308fda0ea6ac24ff5d1e650bac7fa4d242e2aa5911"
},{
  "tool": "Code Inspection",
  "category": "Verbose or redundant code constructs",
  "type": "Unnecessarily escaped character",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "`\\'` is unnecessarily escaped",
  "detailsInfo": "Reports unnecessarily escaped characters in `String` and optionally `char` literals.\n\nEscaped tab characters `\\t` are not reported, because tab characters are invisible.\n\nExamples:\n\n\n      String s = \"\\'Scare\\' quotes\";\n      String t = \"\"\"\n        All you need is\\n\\tLove\\n\"\"\";\n\nAfter the quick-fix is applied:\n\n\n      String s = \"'Scare' quotes\";\n      String t = \"\"\"\n        All you need is\n        \\tLove\n      \"\"\";\n\nNew in 2019.3",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/yaml/references/value/ValueReference.java",
      "language": "JAVA",
      "line": 46,
      "offset": 39,
      "length": 2,
      "code": {
        "startLine": 44,
        "length": 2,
        "offset": 125,
        "surroundingCode": "        String value;\n        value = yamlElement.getText().replaceAll(\"^\\\"|\\\"$\", \"\");\n        value = value.replaceAll(\"^\\'|\\'$\", \"\");\n\n        if (value.startsWith(\"resource://\")) {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UnnecessaryStringEscape"
  },
  "hash": "1e246e3f51e33431d112d74256e058c9ca257d67b4d3e41417694965bc8e608e"
},{
  "tool": "Code Inspection",
  "category": "Verbose or redundant code constructs",
  "type": "Unnecessarily escaped character",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "`\\'` is unnecessarily escaped",
  "detailsInfo": "Reports unnecessarily escaped characters in `String` and optionally `char` literals.\n\nEscaped tab characters `\\t` are not reported, because tab characters are invisible.\n\nExamples:\n\n\n      String s = \"\\'Scare\\' quotes\";\n      String t = \"\"\"\n        All you need is\\n\\tLove\\n\"\"\";\n\nAfter the quick-fix is applied:\n\n\n      String s = \"'Scare' quotes\";\n      String t = \"\"\"\n        All you need is\n        \\tLove\n      \"\"\";\n\nNew in 2019.3",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/yaml/references/value/ValueReference.java",
      "language": "JAVA",
      "line": 46,
      "offset": 36,
      "length": 2,
      "code": {
        "startLine": 44,
        "length": 2,
        "offset": 122,
        "surroundingCode": "        String value;\n        value = yamlElement.getText().replaceAll(\"^\\\"|\\\"$\", \"\");\n        value = value.replaceAll(\"^\\'|\\'$\", \"\");\n\n        if (value.startsWith(\"resource://\")) {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UnnecessaryStringEscape"
  },
  "hash": "adda7f2b812aefc06d5ab316d17d1a6c8e36643a0b3fb2371ee813923428075d"
},{
  "tool": "Code Inspection",
  "category": "Properties files",
  "type": "Invalid property key",
  "tags": [
    "JAVA"
  ],
  "severity": "Critical",
  "comment": "'xml.parsing.unescaped.ampersand.or.nonterminated.character.entity.reference' doesn't appear to be a valid property key",
  "detailsInfo": "Reports invalid arguments that are passed to methods with parameters annotated as `@PropertyKey`.\n\nThese arguments should be valid property keys in corresponding properties files.\nAlso, the inspection verifies that the `resourceBundle`\nargument of the `@PropertyKey` annotation is an existing resource bundle.\n\n\nUse the quick-fix to create a new property or to select an existing one.\n\nExample:\n\n\n      @PropertyKey(resourceBundle = \"myBundle\") String value = \"invalid.key\";\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/afx/parser/AfxParsing.java",
      "language": "JAVA",
      "line": 97,
      "offset": 54,
      "length": 77,
      "code": {
        "startLine": 95,
        "length": 77,
        "offset": 144,
        "surroundingCode": "                    final PsiBuilder.Marker error = mark();\n                    advance();\n                    error.error(XmlPsiBundle.message(\"xml.parsing.unescaped.ampersand.or.nonterminated.character.entity.reference\"));\n                } else if (tt == XmlTokenType.XML_ENTITY_REF_TOKEN) {\n                    parseReference();"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UnresolvedPropertyKey"
  },
  "hash": "849e26ca915bb572291e837001e5ebcda61e4d8059e5de69957360cfc0fb763d"
},{
  "tool": "Code Inspection",
  "category": "Properties files",
  "type": "Invalid property key",
  "tags": [
    "JAVA"
  ],
  "severity": "Critical",
  "comment": "'xml.parsing.unclosed.attribute.value' doesn't appear to be a valid property key",
  "detailsInfo": "Reports invalid arguments that are passed to methods with parameters annotated as `@PropertyKey`.\n\nThese arguments should be valid property keys in corresponding properties files.\nAlso, the inspection verifies that the `resourceBundle`\nargument of the `@PropertyKey` annotation is an existing resource bundle.\n\n\nUse the quick-fix to create a new property or to select an existing one.\n\nExample:\n\n\n      @PropertyKey(resourceBundle = \"myBundle\") String value = \"invalid.key\";\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/afx/parser/AfxParsing.java",
      "language": "JAVA",
      "line": 108,
      "offset": 44,
      "length": 38,
      "code": {
        "startLine": 106,
        "length": 38,
        "offset": 91,
        "surroundingCode": "                advance();\n            } else {\n                error(XmlPsiBundle.message(\"xml.parsing.unclosed.attribute.value\"));\n            }\n        } else {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UnresolvedPropertyKey"
  },
  "hash": "a014f5d8406c2dd61a29e7adb1cfecd776ae56777efd01d0dbb6b65fb13443c9"
},{
  "tool": "Code Inspection",
  "category": "JVM languages",
  "type": "Unstable API Usage",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'com.intellij.diagnostic.AbstractMessage' is marked unstable with @ApiStatus.Internal",
  "detailsInfo": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/errorReporting/SentryErrorReporter.java",
      "language": "JAVA",
      "line": 45,
      "offset": 91,
      "length": 15,
      "code": {
        "startLine": 43,
        "length": 15,
        "offset": 198,
        "surroundingCode": "        ArrayList<String> eventIds = new ArrayList<>();\n        for (IdeaLoggingEvent ideaEvent : events) {\n            if (ideaEvent instanceof IdeaReportingEvent && ideaEvent.getData() instanceof AbstractMessage) {\n                Throwable ex = ((AbstractMessage) ideaEvent.getData()).getThrowable();\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UnstableApiUsage"
  },
  "hash": "062153dd4f3af7a4da206af31040920c37331cb1574999f4eba355e19dd4ec47"
},{
  "tool": "Code Inspection",
  "category": "JVM languages",
  "type": "Unstable API Usage",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'com.intellij.openapi.util.NlsSafe' is marked unstable with @ApiStatus.Experimental",
  "detailsInfo": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/eel/EelFileType.java",
      "language": "JAVA",
      "line": 32,
      "offset": 13,
      "length": 7,
      "code": {
        "startLine": 30,
        "length": 7,
        "offset": 27,
        "surroundingCode": "\n    @Override\n    public @NlsSafe @NotNull String getDefaultExtension() {\n        return \"eel\";\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UnstableApiUsage"
  },
  "hash": "0c43bcb8f0aefac2cbf874dd1c29cb18fea5461255562d18134de883ad885e3a"
},{
  "tool": "Code Inspection",
  "category": "JVM languages",
  "type": "Unstable API Usage",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'com.intellij.codeInsight.hints.InlayParameterHintsProvider' is declared in unstable package 'com.intellij.codeInsight.hints' marked with @ApiStatus.Experimental",
  "detailsInfo": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/eel/codeInsight/hints/EelInlayParameterHintsProvider.java",
      "language": "JAVA",
      "line": 18,
      "offset": 56,
      "length": 27,
      "code": {
        "startLine": 16,
        "length": 27,
        "offset": 78,
        "surroundingCode": "import java.util.Set;\n\npublic class EelInlayParameterHintsProvider implements InlayParameterHintsProvider {\n\n    @Override"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UnstableApiUsage"
  },
  "hash": "1bfdfe59795767839a3cb395f6ac4b2ac08a59a0fb1b54fd54265572dfc945c0"
},{
  "tool": "Code Inspection",
  "category": "JVM languages",
  "type": "Unstable API Usage",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Overridden method 'isBlackListSupported()' is declared in unstable package 'com.intellij.codeInsight.hints' marked with @ApiStatus.Experimental",
  "detailsInfo": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/eel/codeInsight/hints/EelInlayParameterHintsProvider.java",
      "language": "JAVA",
      "line": 26,
      "offset": 20,
      "length": 20,
      "code": {
        "startLine": 24,
        "length": 20,
        "offset": 34,
        "surroundingCode": "\n    @Override\n    public boolean isBlackListSupported() {\n        return false;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UnstableApiUsage"
  },
  "hash": "25bdcfd0f4168666e8fda52f9d880cb7daa0665c23e97e90b9532a8b165e4a7b"
},{
  "tool": "Code Inspection",
  "category": "JVM languages",
  "type": "Unstable API Usage",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'getThrowable()' is declared in unstable class 'com.intellij.diagnostic.AbstractMessage' marked with @ApiStatus.Internal",
  "detailsInfo": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/errorReporting/SentryErrorReporter.java",
      "language": "JAVA",
      "line": 46,
      "offset": 72,
      "length": 12,
      "code": {
        "startLine": 44,
        "length": 12,
        "offset": 232,
        "surroundingCode": "        for (IdeaLoggingEvent ideaEvent : events) {\n            if (ideaEvent instanceof IdeaReportingEvent && ideaEvent.getData() instanceof AbstractMessage) {\n                Throwable ex = ((AbstractMessage) ideaEvent.getData()).getThrowable();\n\n                SentryEvent sentryEvent = new SentryEvent();"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UnstableApiUsage"
  },
  "hash": "263860e30ecdead00829d7ad41117ea49c84acb55ec55ef512829eb80a50779f"
},{
  "tool": "Code Inspection",
  "category": "JVM languages",
  "type": "Unstable API Usage",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'com.intellij.openapi.util.NlsSafe' is marked unstable with @ApiStatus.Experimental",
  "detailsInfo": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/ext/FusionPropertyAssignmentImplMixin.java",
      "language": "JAVA",
      "line": 56,
      "offset": 32,
      "length": 7,
      "code": {
        "startLine": 54,
        "length": 7,
        "offset": 46,
        "surroundingCode": "\n    @Override\n    public PsiElement setName(@NlsSafe @NotNull String name) throws IncorrectOperationException {\n        return this;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UnstableApiUsage"
  },
  "hash": "278a405fbfa75087aa129aeb76a6862d4f976f53d2f970eaaa95e3dc1ea6c83e"
},{
  "tool": "Code Inspection",
  "category": "JVM languages",
  "type": "Unstable API Usage",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'com.intellij.openapi.util.NlsSafe' is marked unstable with @ApiStatus.Experimental",
  "detailsInfo": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/fusion/psi/impl/ext/FusionPrototypeSignatureImplMixin.java",
      "language": "JAVA",
      "line": 86,
      "offset": 32,
      "length": 7,
      "code": {
        "startLine": 84,
        "length": 7,
        "offset": 46,
        "surroundingCode": "\n    @Override\n    public PsiElement setName(@NlsSafe @NotNull String name) throws IncorrectOperationException {\n        FusionTypeImpl type = (FusionTypeImpl)FusionElementFactory.createType(getProject(), name);\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UnstableApiUsage"
  },
  "hash": "2796a2cf4ccae354bd491bda90c358aa9fb5ed19c561a65736e5ec74e8605b74"
},{
  "tool": "Code Inspection",
  "category": "JVM languages",
  "type": "Unstable API Usage",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Overridden method 'getParameterHints(com.intellij.psi.@org.jetbrains.annotations.NotNull PsiElement)' is declared in unstable package 'com.intellij.codeInsight.hints' marked with @ApiStatus.Experimental",
  "detailsInfo": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/eel/codeInsight/hints/EelInlayParameterHintsProvider.java",
      "language": "JAVA",
      "line": 31,
      "offset": 37,
      "length": 17,
      "code": {
        "startLine": 29,
        "length": 17,
        "offset": 51,
        "surroundingCode": "\n    @Override\n    public @NotNull List<InlayInfo> getParameterHints(@NotNull PsiElement element) {\n        ArrayList<InlayInfo> inlayInfos = new ArrayList<>();\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UnstableApiUsage"
  },
  "hash": "587901e3d201c167d3db81fa37e1b6e7c1cf2dd2b5dc87a2effdadbc49357ed9"
},{
  "tool": "Code Inspection",
  "category": "JVM languages",
  "type": "Unstable API Usage",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'com.intellij.openapi.util.NlsSafe' is marked unstable with @ApiStatus.Experimental",
  "detailsInfo": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/search/NavigationItem.java",
      "language": "JAVA",
      "line": 55,
      "offset": 17,
      "length": 7,
      "code": {
        "startLine": 53,
        "length": 7,
        "offset": 35,
        "surroundingCode": "\n        @Override\n        public @NlsSafe String getPresentableText() {\n            return label;\n        }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UnstableApiUsage"
  },
  "hash": "632398bf6c0f47d108abd7c2c4c5ba650b0036bc53840944d16b79a39eec4951"
},{
  "tool": "Code Inspection",
  "category": "JVM languages",
  "type": "Unstable API Usage",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'com.intellij.openapi.util.NlsSafe' is marked unstable with @ApiStatus.Experimental",
  "detailsInfo": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/search/NavigationItem.java",
      "language": "JAVA",
      "line": 60,
      "offset": 17,
      "length": 7,
      "code": {
        "startLine": 58,
        "length": 7,
        "offset": 35,
        "surroundingCode": "\n        @Override\n        public @NlsSafe  String getLocationString() {\n            return SymbolPresentationUtil.getFilePathPresentation(file);\n        }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UnstableApiUsage"
  },
  "hash": "83fd51ee438d37f18bdb0b34857b6aababf30f1684dc4113576961232f8e3c3e"
},{
  "tool": "Code Inspection",
  "category": "JVM languages",
  "type": "Unstable API Usage",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'com.intellij.codeInsight.hints.InlayInfo' is declared in unstable package 'com.intellij.codeInsight.hints' marked with @ApiStatus.Experimental",
  "detailsInfo": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/eel/codeInsight/hints/EelInlayParameterHintsProvider.java",
      "language": "JAVA",
      "line": 32,
      "offset": 19,
      "length": 9,
      "code": {
        "startLine": 30,
        "length": 9,
        "offset": 117,
        "surroundingCode": "    @Override\n    public @NotNull List<InlayInfo> getParameterHints(@NotNull PsiElement element) {\n        ArrayList<InlayInfo> inlayInfos = new ArrayList<>();\n\n        if (element instanceof EelMethodCall) {"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UnstableApiUsage"
  },
  "hash": "96c8be614775b65b9839405badd713613b3debd2835567d2a8ea51fec5c5727c"
},{
  "tool": "Code Inspection",
  "category": "JVM languages",
  "type": "Unstable API Usage",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'com.intellij.codeInsight.hints.InlayInfo' is declared in unstable package 'com.intellij.codeInsight.hints' marked with @ApiStatus.Experimental",
  "detailsInfo": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/eel/codeInsight/hints/EelInlayParameterHintsProvider.java",
      "language": "JAVA",
      "line": 53,
      "offset": 44,
      "length": 9,
      "code": {
        "startLine": 51,
        "length": 9,
        "offset": 154,
        "surroundingCode": "                    Parameter parameter = method.getParameter(i);\n                    if (parameter != null) {\n                        inlayInfos.add(new InlayInfo(parameter.getName(), eelConditionalExpression.getTextOffset()));\n                    }\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UnstableApiUsage"
  },
  "hash": "9da04569eab5c62e64e94243ec5e644125598508ed6657f77fd72032a201da0f"
},{
  "tool": "Code Inspection",
  "category": "JVM languages",
  "type": "Unstable API Usage",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'com.intellij.codeInsight.hints.InlayInfo' is declared in unstable package 'com.intellij.codeInsight.hints' marked with @ApiStatus.Experimental",
  "detailsInfo": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/eel/codeInsight/hints/EelInlayParameterHintsProvider.java",
      "language": "JAVA",
      "line": 31,
      "offset": 26,
      "length": 9,
      "code": {
        "startLine": 29,
        "length": 9,
        "offset": 40,
        "surroundingCode": "\n    @Override\n    public @NotNull List<InlayInfo> getParameterHints(@NotNull PsiElement element) {\n        ArrayList<InlayInfo> inlayInfos = new ArrayList<>();\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UnstableApiUsage"
  },
  "hash": "a794648f12c5a6dbb739f79d950137fd420f4b2c98bf09802dc8da7faec4a178"
},{
  "tool": "Code Inspection",
  "category": "JVM languages",
  "type": "Unstable API Usage",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'com.intellij.diagnostic.IdeaReportingEvent' is marked unstable with @ApiStatus.Internal",
  "detailsInfo": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/errorReporting/SentryErrorReporter.java",
      "language": "JAVA",
      "line": 45,
      "offset": 38,
      "length": 18,
      "code": {
        "startLine": 43,
        "length": 18,
        "offset": 145,
        "surroundingCode": "        ArrayList<String> eventIds = new ArrayList<>();\n        for (IdeaLoggingEvent ideaEvent : events) {\n            if (ideaEvent instanceof IdeaReportingEvent && ideaEvent.getData() instanceof AbstractMessage) {\n                Throwable ex = ((AbstractMessage) ideaEvent.getData()).getThrowable();\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UnstableApiUsage"
  },
  "hash": "b3f0ccfa2298676def3fb633ee7ac28ccadbc8c9d0d34f6a103f377ec1662832"
},{
  "tool": "Code Inspection",
  "category": "JVM languages",
  "type": "Unstable API Usage",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'com.intellij.openapi.util.NlsSafe' is marked unstable with @ApiStatus.Experimental",
  "detailsInfo": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/afx/AfxFileType.java",
      "language": "JAVA",
      "line": 32,
      "offset": 13,
      "length": 7,
      "code": {
        "startLine": 30,
        "length": 7,
        "offset": 27,
        "surroundingCode": "\n    @Override\n    public @NlsSafe @NotNull String getDefaultExtension() {\n        return \"afx\";\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UnstableApiUsage"
  },
  "hash": "c5e05e1825f70ed57e1785f0ca0772631dd99dbb935fd87a3b33d3fbd3b159ee"
},{
  "tool": "Code Inspection",
  "category": "JVM languages",
  "type": "Unstable API Usage",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'InlayInfo(java.lang.String, int)' is declared in unstable package 'com.intellij.codeInsight.hints' marked with @ApiStatus.Experimental",
  "detailsInfo": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/eel/codeInsight/hints/EelInlayParameterHintsProvider.java",
      "language": "JAVA",
      "line": 53,
      "offset": 44,
      "length": 9,
      "code": {
        "startLine": 51,
        "length": 9,
        "offset": 154,
        "surroundingCode": "                    Parameter parameter = method.getParameter(i);\n                    if (parameter != null) {\n                        inlayInfos.add(new InlayInfo(parameter.getName(), eelConditionalExpression.getTextOffset()));\n                    }\n"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UnstableApiUsage"
  },
  "hash": "d126c7d6c0b025d26ed4e842d60ea088bf67e64c3463d5011cb5ded14ca38562"
},{
  "tool": "Code Inspection",
  "category": "JVM languages",
  "type": "Unstable API Usage",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Overridden method 'getDefaultBlackList()' is declared in unstable package 'com.intellij.codeInsight.hints' marked with @ApiStatus.Experimental",
  "detailsInfo": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/lang/eel/codeInsight/hints/EelInlayParameterHintsProvider.java",
      "language": "JAVA",
      "line": 21,
      "offset": 33,
      "length": 19,
      "code": {
        "startLine": 19,
        "length": 19,
        "offset": 47,
        "surroundingCode": "\n    @Override\n    public @NotNull Set<String> getDefaultBlackList() {\n        return Set.of();\n    }"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UnstableApiUsage"
  },
  "hash": "d4e8b1b83e72d59a3967eb6b41bacf639cd52564ac487eb884659e149a787b80"
},{
  "tool": "Code Inspection",
  "category": "JVM languages",
  "type": "Unstable API Usage",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'com.intellij.diagnostic.AbstractMessage' is marked unstable with @ApiStatus.Internal",
  "detailsInfo": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/de/vette/idea/neos/errorReporting/SentryErrorReporter.java",
      "language": "JAVA",
      "line": 46,
      "offset": 34,
      "length": 15,
      "code": {
        "startLine": 44,
        "length": 15,
        "offset": 194,
        "surroundingCode": "        for (IdeaLoggingEvent ideaEvent : events) {\n            if (ideaEvent instanceof IdeaReportingEvent && ideaEvent.getData() instanceof AbstractMessage) {\n                Throwable ex = ((AbstractMessage) ideaEvent.getData()).getThrowable();\n\n                SentryEvent sentryEvent = new SentryEvent();"
      }
    }
  ],
  "attributes": {
    "module": "Intellij_Neos.main",
    "inspectionName": "UnstableApiUsage"
  },
  "hash": "f270f8bdd3928cc5a6fd6b8354c3386ed838c60357826e852e93c01314331559"
}]}